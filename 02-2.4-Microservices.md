**Introduction to Microservices**

**What is a Microservice?**

- A microservice is a software design pattern where applications are built as
    a collection of **small, independent, loosely coupled services**.

- Each service:
  - Focuses on a **single business capability** (e.g., user authentication, payment processing).
  - Runs in its process and communicates via lightweight APIs (e.g., REST, gRPC).
  - Manages its data storage (decentralized databases).

- Contrasts with **monolithic architecture** (single codebase where components are tightly integrated).

**Why Microservice Architecture?**

- **Scalability**:
  
  Scale individual services independently based on demand (e.g., scaling a high-traffic payment service).

- **Flexibility**:
  
  Use different technologies (languages, frameworks) for various services.

- **Resilience**:
  
  Fault isolation – failures in one service don’t crash the entire system.

- **Faster Deployment**:
  
  Teams can develop, test, and deploy services independently.

- **Organizational Alignment**:
  
  Small teams own specific services, enabling agility and autonomy.


```
Example:
  Scenario: Ride-Sharing Platform with Microservices

System Landscape

- User Service:
  Manages rider and driver profiles in a SQL database.

- Trip Service:
  matches riders and drivers, calculates Estimated Time of Arrival (ETA), and stores trip records.

- Pricing Service:
  Computes dynamic fares based on demand, distance, and surge multipliers.

- Notification Service:
  publishes events (e.g., “ride-confirmed”) to Apache Kafka, consumed by email/SMS workers.

- API Gateway:
  routes external Representational State Transfer REST/gRPC calls to each service.                                              Note:gRPC: Google Remote Procedure Call.

Key Design Decisions:

1. Containerization & Orchestration: 
Each service runs in Docker on Kubernetes, enabling autonomous scaling (e.g., spin up more Trip pods during rush hour).

2. Data Ownership:
Every service owns its data store. (e.g., Redis for caching trip lookups, PostgreSQL for persistent records) to avoid cross-service coupling.

3. Inter-service Communication :
Synchronous: gRPC between User and Trip for authentication.
Asynchronous: Kafka topics for events (e.g., pricing updates, notifications) to decouple producers/consumers

Resilience Patterns:

- Circuit Breakers protect the Trip Service from cascading failures when Pricing is down.

- Bulkheads isolate CPU-intensive map-matching jobs to dedicated nodes.

- Retries with exponential backoff on external partner APIs (e.g., maps, payments).


Observability & Automation:

- Distributed Tracing (Jaeger) reveals end-to-end latency (User → Trip →Pricing).

- Prometheus + Grafana alert on Service Level Objective (SLO) breaches (e.g., >1.5 s 95th-percentile trip-create latency).

- Chaos Engineering periodically kills a random Trip pod to verify graceful degradation and fallback to cached pricing.
```

