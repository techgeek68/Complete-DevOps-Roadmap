# 11. Managing Firewalls

This section covers practical Linux firewall management, opening/closing ports, and configuring security modules like SELinux and AppArmor.  
Commands are grouped by tool and include verification methods. Explanations and "Best Practice" notes are added for clarity.

---

## Firewall Tools Overview

- **iptables**: Traditional, low-level rule-based firewall. Powerful but verbose.
- **firewalld**: Dynamic firewall manager for RHEL/CentOS/Fedora. Easier for services/zones.
- **ufw**: Uncomplicated Firewall. Simplified for Debian/Ubuntu.

_Best Practice:_  
Choose the tool your distro supports natively. Use firewalld on RHEL/CentOS, ufw on Ubuntu, and iptables for direct control.

---

## Configuring Firewalls

### A. Using `iptables`

_List all rules:_
```bash
sudo iptables -L -n -v
```

_Save rules (to persist after reboot):_
```bash
# Debian/Ubuntu
sudo iptables-save > /etc/iptables/rules.v4

# RHEL/CentOS
sudo service iptables save
```

_Allow incoming SSH (port 22):_
```bash
sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
```
- `-A INPUT`: Append rule to INPUT chain.
- `-p tcp`: Protocol TCP.
- `--dport 22`: Destination port 22 (SSH).
- `-j ACCEPT`: Accept connection.

_Allow incoming HTTP (port 80):_
```bash
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
```

_List current rules with line numbers:_
```bash
sudo iptables -L INPUT --line-numbers -n
```

_Delete a rule by number (example: delete rule 1):_
```bash
sudo iptables -D INPUT 1
```

_Block an IP address:_
```bash
sudo iptables -A INPUT -s 192.168.1.100 -j DROP
```

_Block an IP on a specific port (example: SSH):_
```bash
sudo iptables -A INPUT -s 192.168.1.100 -p tcp --dport 22 -j DROP
```

_Check if an IP is blocked:_
```bash
sudo iptables -L INPUT -n | grep 192.168.1.100
# No output → not blocked
# DROP in output → blocked
```

_Unblock an IP:_
```bash
sudo iptables -L INPUT --line-numbers -n
sudo iptables -D INPUT 3  # Example: remove rule 3
```

_Verify unblock:_
```bash
sudo iptables -L INPUT -n | grep 192.168.1.100
```

_Best Practice:_  
Always verify changes after modifying firewall rules. Keep a backup of your rules before making bulk changes.

---

### B. Using `firewalld`

_List all rules:_
```bash
firewall-cmd --list-all
```

_Allow HTTP/HTTPS/SSH services:_
```bash
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --permanent --add-service=ssh
```

_Open a specific port (e.g., 8080):_
```bash
sudo firewall-cmd --permanent --add-port=8080/tcp
```

_Reload firewall (apply changes):_
```bash
sudo firewall-cmd --reload
```

_Remove/Block a service:_
```bash
sudo firewall-cmd --permanent --remove-service=ssh
sudo firewall-cmd --reload
```

_Verify removal:_
```bash
sudo firewall-cmd --list-all
```

_Block/Unblock an IP:_
```bash
# Block a single IP
sudo firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.1.100" reject'
sudo firewall-cmd --reload

# Unblock
sudo firewall-cmd --permanent --remove-rich-rule='rule family="ipv4" source address="192.168.1.100" reject'
sudo firewall-cmd --reload
```
- `reject` sends "connection refused"; use `drop` for silent blocking.

_Block an IP range (CIDR):_
```bash
sudo firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.1.0/24" reject'
sudo firewall-cmd --reload
```

_Verify status:_
```bash
sudo firewall-cmd --list-services
sudo firewall-cmd --list-all
```

_Best Practice:_  
Use `--permanent` for changes that need to persist after reboot. Always reload after modifying rules.

---

### C. Using `ufw`

_Enable UFW:_
```bash
sudo ufw enable
```

_Allow SSH:_
```bash
sudo ufw allow ssh
```

_Open port 443 (HTTPS):_
```bash
sudo ufw allow 443/tcp
```

_Deny port 21 (FTP):_
```bash
sudo ufw deny 21
```

_Check status:_
```bash
sudo ufw status verbose
```

_Block an IP:_
```bash
sudo ufw deny from 192.168.1.50
```

_Best Practice:_  
Use service names for common ports. For anything custom, specify port/protocol.

---

## Opening/Closing Ports & Services

- Prefer service names (e.g., `ssh`, `http`) to simplify rules.
- Use custom ports for unlisted services.
- Firewalld’s `--permanent` and iptables-save ensure persistence.

_Best Practice:_  
Document all firewall changes for audit purposes, especially in production.

---

## SELinux and AppArmor

### A. SELinux (Security-Enhanced Linux)

_Check status:_
```bash
sestatus
getenforce
```
- `Enforcing`: Active, blocking violations.
- `Permissive`: Logging, not blocking.
- `Disabled`: Off.

_Set mode temporarily:_
```bash
sudo setenforce 0  # Permissive
sudo setenforce 1  # Enforcing
```

_Set mode permanently:_
```bash
sudo vi /etc/selinux/config
```

_Allow a service (HTTP on port 8080):_
```bash
sudo semanage port -a -t http_port_t -p tcp 8080
```

_Allow SMTP & MySQL:_
```bash
sudo semanage port -a -t smtp_port_t -p tcp 25
sudo semanage port -a -t mysqld_port_t -p tcp 3306
```

_Verify allowed ports:_
```bash
sudo semanage port -l
sudo semanage port -l | grep http
sudo semanage port -l | grep smtp
```

_Troubleshooting SELinux:_
```bash
sudo ausearch -m avc -ts recent
sealert -a /var/log/audit/audit.log
```

_Best Practice:_  
Use Enforcing in production. Permissive is only for troubleshooting. Avoid disabling SELinux unless absolutely necessary.

---

### B. AppArmor

_Check status:_
```bash
sudo apparmor_status
```

_Set profile mode (enforce/complain):_
```bash
sudo aa-enforce /path/to/profile
sudo aa-complain /path/to/profile
```

_Reload profiles:_
```bash
sudo systemctl reload apparmor
```

_Adjust profiles based on logs:
```bash
sudo aa-logprof
```
Profiles are located in `/etc/apparmor.d/`.

_Troubleshooting:_
- Check `/var/log/syslog` or `/var/log/kern.log` for AppArmor denials.

_Best Practice:_  
Regularly review AppArmor logs for denied actions and tune profiles with `aa-logprof`.

---

## Troubleshooting Connectivity

_Check firewall rules:_
```bash
sudo iptables -L -n -v
firewall-cmd --list-all
ufw status
```

_Check port listening:_
```bash
sudo ss -tulpn
sudo netstat -tulpn
```

_Check SELinux/AppArmor denials:_
- SELinux: `/var/log/audit/audit.log` or `journalctl`
- AppArmor: `/var/log/syslog`, `/var/log/kern.log`

---

## Examples

_Allow Nginx via firewalld:_
```bash
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --reload
```
_Verification:_
```bash
firewall-cmd --list-services
```

_Block an IP with ufw:_
```bash
sudo ufw deny from 192.168.1.50
```
_Verification:_
```bash
sudo ufw status
```

_Adjust SELinux for a custom service:_
```bash
sudo semanage port -a -t http_port_t -p tcp 8080
```
_Verification:_
```bash
sudo semanage port -l | grep 8080
```

---

## Additional Topics for DevOps Engineers

---

### 1. Managing Security Groups in Cloud (AWS, Azure, GCP)

Cloud environments use Security Groups and Network ACLs that function like firewalls but are managed differently.

**AWS Example:**
```bash
# List security groups
aws ec2 describe-security-groups

# Add a rule to allow SSH
aws ec2 authorize-security-group-ingress --group-id sg-12345678 --protocol tcp --port 22 --cidr 0.0.0.0/0

# Remove a rule
aws ec2 revoke-security-group-ingress --group-id sg-12345678 --protocol tcp --port 22 --cidr 0.0.0.0/0
```
_Verifying:_
- Use AWS Console or `aws ec2 describe-security-groups` to check rules.

_Best Practice:_  
Restrict access by CIDR as much as possible—never use 0.0.0.0/0 in production.

**Azure Example (using Azure CLI):**
```bash
# List NSG (Network Security Group) rules
az network nsg rule list --resource-group myResourceGroup --nsg-name myNSG

# Add a rule to allow SSH
az network nsg rule create --resource-group myResourceGroup --nsg-name myNSG --name AllowSSH --protocol tcp --direction inbound --priority 1000 --source-address-prefixes '*' --destination-port-ranges 22 --access Allow

# Remove a rule
az network nsg rule delete --resource-group myResourceGroup --nsg-name myNSG --name AllowSSH
```
_Verifying:_
- Check rules with `az network nsg rule list` or via the Azure Portal.

_Best Practice:_  
Always set a specific source address/range (avoid '*') except for testing.

**GCP Example (using gcloud):**
```bash
# List firewall rules
gcloud compute firewall-rules list

# Add a rule to allow SSH
gcloud compute firewall-rules create allow-ssh --direction=INGRESS --priority=1000 --network=default --action=ALLOW --rules=tcp:22 --source-ranges=0.0.0.0/0

# Remove a rule
gcloud compute firewall-rules delete allow-ssh
```
_Verifying:_
- Use `gcloud compute firewall-rules list` or check in GCP Console.

_Best Practice:_  
Use restrictive source ranges. Audit rules frequently in cloud environments.

---

### 2. Monitoring Firewall Activity

Being able to review logs and monitor for suspicious activity is essential.

**Example:**
```bash
# View UFW logs
sudo tail -f /var/log/ufw.log

# View iptables logs (often in syslog)
sudo grep 'iptables' /var/log/syslog
```
_Verifying:_
- Check for repeated denied connections or port scans.

_Best Practice:_  
Set up log rotation and forwarding to a SIEM/log management tool.

---

### 3. Automating Firewall Rules (Infrastructure as Code)

DevOps engineers often manage firewall rules via automation tools.

**Example with Ansible:**
```yaml
- name: Allow HTTP with firewalld
  ansible.builtin.firewalld:
    service: http
    permanent: yes
    state: enabled
```
_Verifying:_
- Run playbook and check with `firewall-cmd --list-services`.

_Best Practice:_  
Version control all infrastructure changes, including firewall rules.

---

### 4. Handling Firewall Rules in Containers (Docker/Kubernetes)

Containers have their own networking. Sometimes, you must open ports or use network policies.

**Docker Example:**
```bash
# Run container exposing port 8080
docker run -d -p 8080:8080 myapp
```
_Verifying:_
- Access with `curl localhost:8080`.

**Kubernetes Example (NetworkPolicy):**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-nginx
spec:
  podSelector:
    matchLabels:
      app: nginx
  ingress:
    - from:
        - ipBlock:
            cidr: 10.0.0.0/24
```
_Verifying:_
- Use `kubectl describe networkpolicy allow-nginx`.

_Best Practice:_  
Apply least-privilege policies—only allow necessary traffic between pods/nodes.

---

### 5. Port Scanning and Validation

Knowing how to check open ports externally is important for verification.

**Example:**
```bash
# Scan open ports on localhost
nmap localhost

# Scan remote host
nmap -Pn example.com
```
_Verifying:_
- Review `nmap` results for undesired open ports.

_Best Practice:_  
Regularly scan your infrastructure to catch misconfigurations.

---

### 6. Quick Overview: VPNs and Secure Remote Access

VPNs are often used to secure connections to infrastructure.

**OpenVPN Example:**
```bash
# Connect to VPN
sudo openvpn --config client.ovpn
```
_Verifying:_
- Check with `ip a` for tun0 interface.
- Try accessing remote resources.

_Best Practice:_  
Enforce multi-factor authentication (MFA) for VPN access.

---

### 7. Incident Response: Lockdown Procedures

Know how to quickly restrict all access in case of a breach.

**Example:**
```bash
# Block all incoming except SSH
sudo ufw default deny incoming
sudo ufw allow ssh
```
_Verifying:_
- Test connectivity from a remote machine.

_Best Practice:_  
Have pre-documented lockdown steps for emergencies.

---

## Advanced Topics for DevOps Engineers

---

### 8. Integrating Firewall Changes with CI/CD Pipelines

Automating firewall rule changes as part of your deployment pipeline helps ensure infrastructure stays secure and compliant as code changes are released.

**Example (GitHub Actions with Ansible):**
```yaml
name: Apply Firewall Rules

on:
  push:
    branches:
      - main

jobs:
  firewall:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Ansible
        run: sudo apt-get install -y ansible
      - name: Apply Firewall Playbook
        run: ansible-playbook firewall.yml
```
_Verifying:_
- Check your infrastructure for rule application after the pipeline runs.
- Review pipeline output logs for any errors or skipped tasks.

_Best Practice:_  
Require code review and approvals on infrastructure code changes, especially for firewall rules.

---

### 9. Automated Compliance Checks

Tools like Chef InSpec or OpenSCAP can be used to audit firewall settings and ensure they meet compliance requirements (PCI, HIPAA, etc.).

**Example (Chef InSpec):**
```ruby
describe iptables do
  it { should have_rule('-A INPUT -p tcp --dport 22 -j ACCEPT') }
  it { should_not have_rule('-A INPUT -p tcp --dport 23 -j ACCEPT') }
end
```
_Verifying:_
- Run `inspec exec <profile>` and review reports.
- Integrate compliance checks into CI/CD or scheduled jobs.

_Best Practice:_  
Automate compliance checks and alert on deviations.

---

### 10. Centralized Firewall Management at Scale

Managing multiple firewall instances can be centralized using tools like FirewallD with Cockpit, cloud-native security dashboards, or third-party platforms.

**Example (Cockpit for FirewallD):**
- Access Cockpit via web (`https://server-ip:9090`) and use GUI to manage firewalld zones, services, ports, and rich rules.

**Example (AWS Security Hub/Azure Security Center/GCP Security Command Center):**
- Use dashboards to review, update, and audit firewall rules across many resources.

_Verifying:_
- Review dashboard reports and alerts for misconfigurations.

_Best Practice:_  
Use role-based access control (RBAC) for management tools.

---

### 11. Multi-Cloud Networking and Firewall Coordination

In complex architectures, you may need to coordinate firewall rules across AWS, Azure, and GCP.

**Example (Terraform multi-cloud):**
```hcl
resource "aws_security_group" "web" {
  # AWS Security Group Rules...
}
resource "azurerm_network_security_group" "web" {
  # Azure NSG Rules...
}
resource "google_compute_firewall" "web" {
  # GCP Firewall Rules...
}
```
_Verifying:_
- Use each cloud's CLI or dashboard to check provisioning and rule consistency.

_Best Practice:_  
Keep all infrastructure as code in a single repo or mono-repo for coordination.

---

### 12. Real-World Audit, Reporting, and Alerting

Set up automated reports and alerts for firewall changes and suspicious events.

**Example (Log aggregation):**
```bash
# Forward logs to central syslog server
*.* @syslog-server.example.com:514
```
**Example (CloudWatch for AWS):**
- Create alarms for security group changes or denied connections.

_Verifying:_
- Check dashboards, email alerts, and incident tickets.

_Best Practice:_  
Alert on rule changes, new open ports, and denied connection spikes.

---

### 13. Recommended Learning and Reference Resources

- [AWS Security Groups Documentation](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html)
- [Azure Network Security Groups](https://docs.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview)
- [GCP Firewall Rules](https://cloud.google.com/vpc/docs/firewalls)
- [iptables Tutorial](https://wiki.nftables.org/wiki-nftables/index.php/Iptables-translate)
- [firewalld Documentation](https://firewalld.org/documentation/)
- [UFW Manual](https://help.ubuntu.com/community/UFW)
- [SELinux Project](https://selinuxproject.org/page/Main_Page)
- [AppArmor Documentation](https://gitlab.com/apparmor/apparmor/wikis/home)
- [Chef InSpec](https://www.chef.io/products/chef-inspec)

---

Best Practice:  
Continuously evolve your firewall management and security monitoring as your infrastructure grows and changes.
