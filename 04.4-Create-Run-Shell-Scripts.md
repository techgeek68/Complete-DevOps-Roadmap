# 6. Creating and Running Bash Shell Scripts

---

Bash scripting is a foundational skill for DevOps engineers, enabling automation, orchestration, system monitoring, rapid troubleshooting, CI/CD integration, and other key tasks. This guide covers practical script creation, variables, control structures, I/O, debugging, and real-world DevOps examples.

---

**Terminal vs Shell**:

- Shell: command-line interpreter that runs commands and scripts (bash, zsh, sh, fish).
- Terminal emulator: a program that hosts the shell (GNOME Terminal, xterm, iTerm2).

| Component         | Function                                 | Examples                |
|-------------------|------------------------------------------|-------------------------|
| Shell             | Executes user commands and scripts       | bash, zsh, sh, fish     |
| Terminal Emulator | Displays shell interface, handles I/O    | GNOME Terminal, xterm   |

Common shells:
- Bourne (sh): original Unix shell—basic, reliable.
- C shell (csh): C-like syntax; interactive use.
- Korn (ksh): mixes sh and csh; script-friendly.
- Bash: enhanced sh with history, completion, and arrays.


**What is Bash and Why Use It**
- Bash (Bourne Again SHell) Bash is the common command-line shell on Unix/Linux that lets you run commands and write scripts to automate tasks.
- Portable scripts, rich control flow, integrates with Unix tools, great for automation/CI/CD.

**Shebang Line**
- Every Bash script should start with a shebang to specify the interpreter:
```sh
#!/bin/bash
```

**Comments**
- Use `#` for comments:
```sh
# This is a comment
echo "Hello World" # Inline comment
```

---

**Constants**:

Constants are values that do not change during the execution of the script. Bash does not have native constant variables, but you can use `readonly` or `declare -r` to simulate constants.

Examples:

```bash
readonly PI=3.14159
echo $PI  # Output: 3.14159
```

```bash
declare -r MAX_USERS=100
echo "Max users allowed: $MAX_USERS"
```

```bash
declare -r URL="https://github.com"
echo $URL  # Output: https://github.com
```

*Attempting to change a constant will result in an error:*
```bash
PI=3  # bash: PI: readonly variable
```

<img width="644" height="207" alt="Screenshot 2025-10-19 at 8 07 17 AM" src="https://github.com/user-attachments/assets/e7f8e03f-5d5c-4b29-92b1-3642257bd539" />


---


# Operators in Bash Scripting

Bash scripting supports a wide range of operators used for performing arithmetic, string manipulation, and testing conditions. Here’s a categorized overview of the most important operators for scripting and automation:


1. **Arithmetic Operators**
Used for numeric calculations. Often used within `$(( ... ))` or `let` command.

| Operator | Description        | Example                |
|----------|--------------------|------------------------|
| `+`      | Addition           | `echo $((2 + 3))`      |
| `-`      | Subtraction        | `echo $((5 - 1))`      |
| `*`      | Multiplication     | `echo $((4 * 2))`      |
| `/`      | Division           | `echo $((8 / 2))`      |
| `%`      | Modulus (remainder)| `echo $((7 % 3))`      |
| `**`     | Exponentiation     | `echo $((2 ** 3))`     |
| `++`     | Increment          | `((count++))`          |
| `--`     | Decrement          | `((count--))`          |


2. **Relational (Comparison) Operators**
Used for comparing numbers (within `test`, `[ ... ]`, or `[[ ... ]]`).

| Operator | Description                | Example                   |
|----------|----------------------------|---------------------------|
| `-eq`    | Equal to                   | `[ "$a" -eq "$b" ]`       |
| `-ne`    | Not equal to               | `[ "$a" -ne "$b" ]`       |
| `-lt`    | Less than                  | `[ "$a" -lt "$b" ]`       |
| `-le`    | Less than or equal to      | `[ "$a" -le "$b" ]`       |
| `-gt`    | Greater than               | `[ "$a" -gt "$b" ]`       |
| `-ge`    | Greater than or equal to   | `[ "$a" -ge "$b" ]`       |


3. **String Operators**
Used for comparing strings.

| Operator  | Description                                 | Example                          |
|-----------|---------------------------------------------|----------------------------------|
| `=` or `==` | Equal to                                 | `[ "$a" = "$b" ]`                |
| `!=`      | Not equal to                               | `[ "$a" != "$b" ]`               |
| `<`       | Less than (lexicographically)              | `[[ "$a" < "$b" ]]`              |
| `>`       | Greater than (lexicographically)           | `[[ "$a" > "$b" ]]`              |
| `-z`      | String is empty                            | `[ -z "$a" ]`                    |
| `-n`      | String is not empty                        | `[ -n "$a" ]`                    |


4. **File Test Operators**
Used to test file types and permissions.

| Operator | Description                                  | Example                        |
|----------|----------------------------------------------|--------------------------------|
| `-e`     | File exists                                  | `[ -e file.txt ]`              |
| `-f`     | File is a regular file                       | `[ -f file.txt ]`              |
| `-d`     | File is a directory                          | `[ -d /var/log ]`              |
| `-r`     | File is readable                             | `[ -r config.cfg ]`            |
| `-w`     | File is writable                             | `[ -w output.log ]`            |
| `-x`     | File is executable                           | `[ -x script.sh ]`             |


5. **Logical Operators**
Used for combining multiple conditions.

| Operator | Meaning                    | Example                              |
|----------|----------------------------|--------------------------------------|
| `&&`     | AND (both must be true)    | `[ "$a" -gt 0 ] && [ "$b" -gt 0 ]`   |
| `\|\|`     | OR (either can be true)  | `[ "$a" -gt 0 ] \|\| [ "$b" -gt 0 ]` |
| `!`      | NOT (negates condition)    | `[ ! -f file.txt ]`                  |


6. **Assignment Operators**
Used to assign values to variables.

| Operator | Description                  | Example                |
|----------|------------------------------|------------------------|
| `=`      | Assign value                 | `name="devops"`        |
| `+=`     | Add and assign (arithmetic)  | `((a += 3))`           |
| `-=`     | Subtract and assign          | `((a -= 2))`           |
| `*=`     | Multiply and assign          | `((a *= 4))`           |
| `/=`     | Divide and assign            | `((a /= 2))`           |
| `%=`     | Modulus and assign           | `((a %= 3))`           |


7. **Other Useful Operators**

| Operator | Description                   | Example                    |
|----------|-------------------------------|----------------------------|
| `,`      | Sequence operator             | `{ echo A; echo B; }`      |
| `;`      | Command separator             | `cmd1; cmd2`               |
| `&`      | Run in background             | `./script.sh &`            |
| `\|`      | Pipe output                  | `ls \| grep txt`            |
| `>`      | Redirect output (overwrite)   | `ls > files.txt`           |
| `>>`     | Redirect output (append)      | `echo "hi" >> log.txt`     |
| `<`      | Redirect input                | `cat < file.txt`           |

---


# Data Types

Data types represent the kind of values a variable can store. In Bash, all variables are treated as strings by default, but you can work with integers, floating-point numbers (with external tools), and simulate booleans.

**Common Data Types in Bash:**
 - **Integer:** Whole numbers (e.g., 5, -10)
 - **Float:** Decimal numbers (not natively supported, but can use `bc` or `awk`)
 - **String:** Sequence of characters
 - **Boolean:** Simulated using integers (0 for true, 1 for false) or strings ("true"/"false")

**Examples:**

**Integer:**
```bash
num=10
let "result=num + 5"
echo $result
```

<img width="657" height="120" alt="Screenshot 2025-10-19 at 8 09 03 AM" src="https://github.com/user-attachments/assets/fdec9779-d2eb-4f90-91ee-a8c3c0ba9c50" />

**Float:**
```bash
float_result=$(echo "3.14 + 2.71" | bc)
echo $float_result  # Output: 5.85
```

**String:**
```bash
name="Alice"
echo "Hello, $name!"  # Output: Hello, Alice!
```

**Boolean (simulated):**
```bash
is_valid=true
if [ "$is_valid" = "true" ]; then
    echo "Valid!"
fi
```

---

**Expressions**:

Expressions in Bash combine variables, constants, and operators to produce a value. They are used for calculations, comparisons, and string operations.

**Examples:**

**Arithmetic Expressions:**
```bash
a=5
b=3
sum=$((a + b))
echo $sum 
```

<img width="664" height="132" alt="Screenshot 2025-10-19 at 8 14 14 AM" src="https://github.com/user-attachments/assets/146f14e3-18f0-42f0-bdd2-183fd547b0d5" />


**String Expressions:**
```bash
str1="Hello"
str2="World"
message="$str1, $str2!"
echo $message
```

<img width="535" height="156" alt="Screenshot 2025-10-19 at 8 16 10 AM" src="https://github.com/user-attachments/assets/7a6e10ee-6e59-4ca1-a086-85db5c17291c" />


**Logical Expressions:**
```bash
x=10
y=20
if [ "$x" -lt "$y" ] && [ "$y" -gt 15 ]; then
  echo "Condition met!"
fi
```

<img width="660" height="152" alt="Screenshot 2025-10-19 at 8 27 46 AM" src="https://github.com/user-attachments/assets/2fa01c51-d57f-4896-acfa-700c39281000" />

> will print: Condition met!
> Why? because both conditions are true (10 < 20 and 20 > 15).

---


## Variables:
Variables are used to store data that can be referenced and manipulated throughout a script. Bash variables are untyped, meaning they can hold various types of data such as numbers, characters, or strings.
Defining variables:
          `variable_name=value`
Calling variables:
          `echo $<variable_name>`
        
**Rules**
- **No spaces around `=`:** Write assignments without spaces (e.g., `my_variable="Hello"` not `my_variable = "Hello"`).
  
- **Quoting values with spaces:** Use single or double quotes if the value includes spaces (e.g., `my_string="Hello World"`).
  
- **Naming conventions:**
  * Use letters, numbers, and underscores only.
  * Do not start with a number.
  * Variable names are case-sensitive (`myVar` ≠ `myvar`).


**Common Environmental Variables**
```sh
echo $HOME      # Home directory
echo $USER      # Current user
echo $PATH      # Executable search path
echo $SHELL     # Default shell
echo $PWD       # Present working directory
```

<img width="770" height="209" alt="Screenshot 2025-10-19 at 8 42 45 AM" src="https://github.com/user-attachments/assets/38ae1437-ad70-45bf-ba36-d4bc84327cac" />


**Local Variables**:
A local variable in Bash is a variable that is defined and used only within the current shell or script (not inherited by subprocesses unless exported). Just assign with `variable=value` for a local variable in scripts or shell.

Examples:

```sh
name="phpdev"
echo "Hello, $name"
```

```sh
count=10
echo "Count is $count"
```

```sh
app="nginx"
echo "App: $app"
```

**Scope in Functions:**
Inside a function, you can use local to restrict the variable's scope.

Example:
```sh
my_func() {
  local temp="temporary value"
  echo "$temp"
}
```
```sh
my_func
```
echo "$temp"     #This would be empty outside the function

<img width="764" height="192" alt="Screenshot 2025-10-19 at 8 47 48 AM" src="https://github.com/user-attachments/assets/aaf46a5e-d484-41dd-9f1b-7a56e8500899" />


**Interactive scripts**

```sh
read -p "Enter target hostname: " host
echo "Target is $host"
```

```sh
read -sp "Enter your secret: " secret
echo -e "\nSecret captured."
```
```
echo $secret 
```

<img width="769" height="159" alt="Screenshot 2025-10-19 at 8 51 47 AM" src="https://github.com/user-attachments/assets/d182bdd0-8145-47a7-ae39-cddbed7aa2a8" />



| Option | Command        | Purpose                                  |
|--------|----------------|------------------------------------------|
| `-s`   | `read`         | Silent (hide user input)                 |
| `-p`   | `read`         | Prompt (show message before input)       |
| `-e`   | `echo`         | Enable backslash escape interpretation   |


---


## 2. Creating and Running a Script

**Basic Script Structure**

Example:

Create a new file:
```
vim scriptexample.sh
```

Script content:
```
#!/bin/bash
echo "This is my first script!"
echo "and my current working directory is" $PWD
```

Make executable:
```
chmod +x scriptexample.sh
```

Run:
```
./scriptexample.sh
```

<img width="767" height="114" alt="Screenshot 2025-10-19 at 8 58 31 AM" src="https://github.com/user-attachments/assets/c7955497-07c2-43d9-86b6-d5a50a465ee6" />


---

## 3. Setting Scripts on the PATH

**Make Scripts Globally Available**

Example:
Create a new file:
```sh
vim deploy.sh
```

Sample script:
```sh
if [ -z "$env" ]; then
  read -p "Enter environment (e.g. prod): " env
fi
echo "Deploying to $env environment"
```

Create a directory for custom scripts:
```sh
mkdir ~/bin
mv deploy.sh ~/bin/
cd ~/bin
chmod +x deploy.sh
```

Add to PATH in `.bashrc`:
```sh
echo 'export PATH=$PATH:~/bin' >> ~/.bashrc
```
```sh
source ~/.bashrc
```
```
cd
```
```sh
deploy.sh
```


<img width="755" height="262" alt="Screenshot 2025-10-19 at 11 15 44 AM" src="https://github.com/user-attachments/assets/4e4079f0-111a-4aeb-82af-073a26deb81d" />



**System-wide for all system users**
```
vim /etc/profile
```
Add:
```
export PATH=$PATH:~/<script_name>
```
Reload:
```
source /etc/profile
```

---


## 4. Control Structure:
 Control structures determine the flow of execution in a script based on conditions or iteration. In Bash:
 - A command’s exit status (0 = success/true, nonzero = failure/false) drives most conditionals.
 - Conditions often execute real commands (e.g., `grep`, `test`) rather than only boolean expressions.
 - Tests can be done with [ ... ] `POSIX test` , [[ ... ]] `Extended test` (Bash-specific), or (( ... )) `Arithmetic `.


**Core Rules and Concepts**:

**- Exit status:**
  - `if cmd; then ... fi` runs the “then” block if `cmd` returns 0.
  - Use `set -euo pipefail` in production scripts, but understand its caveats (see Pitfalls).
  
**- Testing syntaxes:**
  - POSIX test: `[ expression ]` (aka `test`). Quote variables: `"$var"`.
  - Bash test: `[[ expression ]]` (safer, no word-splitting/globbing; supports patterns and regex).
  - Arithmetic: `(( expression ))` (integers only; returns 0 if expression ≠ 0).
  
**- String vs integer:**
  - Strings: `=` `!=` (POSIX), `<` `>` in `[[ ... ]]` are lexicographic; in `[ ... ]`, `<` `>` are redirections—must escape or avoid.
  - Integers: `-eq` `-ne` `-lt` `-le` `-gt` `-ge` or use arithmetic context `(( a < b ))`.
  
**- File tests (common):**
  - `-e` exists, `-f` regular file, `-d` directory, `-s` size > 0
  - `-r` readable, `-w` writable, `-x` executable, `-L` symlink
  - `file1 -nt file2` newer-than, `file1 -ot file2` older-than
  
**- Patterns and regex:**
  - Glob patterns: `[[ $v == pat* ]]` and `case` use globs (`* ? [ ]`).
  - Regex: `[[ $v =~ ^re$ ]]` uses ERE; the right-hand side should be unquoted. Capture groups: `${BASH_REMATCH[n]}`.
  
**- Quoting:**
  - Always quote variables in commands and in `[ ... ]`: `"$var"`.
  - In `[[ ... ]]`, unquoted variables won’t word-split or glob, but quote when you need literal matching.
  
**- Arithmetic context specifics:**
  - `(( ... ))` treats unset vars as 0 (even under `set -u`), which can hide bugs—initialize explicitly.
  
**- Loop control depth:**
  - `break [n]` and `continue [n]` accept a numeric level for nested loops. `continue 2` advances the next iteration of the 2nd enclosing loop.

**Portability note:**
- Prefer `[ ... ]` and avoid Bash-only features if targeting `/bin/sh`.
- `[[ ... ]]`, `(( ... ))`, `=~`, `;;&`, `;&`, and `select` are Bash-specific.


**Control Structures**:
```
│
├─ 1. Conditional Statements
│    ├─ if / elif / else
│    └─ switch / case
│
├─ 2. Looping Constructs
│    ├─ for
│    ├─ while
│    └─ until
│
└─ 3. Loop Control Statements
     ├─ break
     └─ continue
```

**if Statement**
In Bash scripting, the if statement enables the conditional execution of commands based on the evaluation of a condition.

**Syntax:**

**if / elif / else**

```sh
if [ condition ]; then
  # commands if condition is true
fi
```

```sh
if command; then
  # commands when the command exit status is 0
elif other_command; then
  # ...
else
  # ...
fi
```

**Examples**:


**Example 1**
```bash
#!/bin/bash
# Simple script demonstrating different types of tests in Bash

# Set example variables
path="/etc/passwd"
x=15

# POSIX-style test using [ ]
if [ -f "$path" ] && [ -r "$path" ]; then
  echo "Readable file"
fi

# Bash-style test using [[ ]]
if [[ -f $path && -r $path ]]; then
  echo "Readable file (Bash)"
fi

# Arithmetic comparison using (( ))
if (( x > 10 )); then
  echo "x is greater than 10"
fi
```

<img width="744" height="152" alt="Screenshot 2025-10-19 at 1 02 57 PM" src="https://github.com/user-attachments/assets/a36ef7c5-709b-450e-abda-83ec5c4f3245" />

**Example 2**
```
read -p "Enter your age: " age
if [ $age -ge 18 ]; then
  echo "You are an adult."
elif [ $age -ge 13 ]; then
  echo "You are a teenager."
else
  echo "You are a child."
fi
```

<img width="747" height="339" alt="Screenshot 2025-10-19 at 1 04 44 PM" src="https://github.com/user-attachments/assets/20a2c18b-5961-43ad-8b2e-c6495bfc2c86" />

**Example 3**
```
read -p "Enter yes or no: " answer
if [ "$answer" = "yes" ]; then
  echo "Affirmative."
else
  echo "Negative or unknown."
fi
```

<img width="743" height="185" alt="Screenshot 2025-10-19 at 1 08 08 PM" src="https://github.com/user-attachments/assets/0dd2a371-3621-41f6-8a32-51d14a401fe0" />


### **case Statement**

- The case statement is a multi-way branch that matches a single word/string against one or more shell glob patterns.
- Use it for command dispatch, option parsing, filename/type handling, interactive prompts, and any situation where you need pattern-based branching.
- Patterns are shell globs (not regular expressions).

Syntax:
```
case "$word" in
  pattern1)
    commands
    ;;
  pattern2|alt)
    commands
    ;;
  "")
    commands_for_empty_string
    ;;
  *)
    default_commands
    ;;
esac
```

Quote the word: 
 - case "$word" in … to handle empty strings and whitespace safely.
 - Each pattern ends with ) and the block ends with ;;.
    - is the default branch if nothing else matches.
   
Pattern rules (globs):
- matches any string (including empty).
- ? matches any single character.
- [abc] matches one character from the class; [a-z] is a range.
- [!a-z] or [^a-z] (shell variant) matches negation inside [].
- Use | to separate alternatives in one case pattern: start|begin)
- Patterns are matched in order; the first matching pattern is taken (unless using bash fall-through extensions described below).
- Patterns are glob-based; they do not support regex constructs like +, {n}, or anchors.

**Examples**

**Example 1: Confirmation prompt**
```
#!/usr/bin/env bash

read -p "Remove all logs? (y/N): " ans
case "$ans" in
  y|Y|yes|Yes)
    echo "Removing logs..."
    # rm -rf /var/log/myapp/*.log
    ;;
  n|N|no|No|"")
    echo "Aborted."
    ;;
  *)
    echo "Please answer yes or no."
    ;;
esac
```

**Example 2:Basic command dispatch (service script)**

```
vim casestatement.sh
```

```
case $1 in
  start)
    echo "Starting service..."
    ;;
  stop)
    echo "Stopping service..."
    ;;
  restart)
    echo "Restarting service..."
    ;;
  *)
    echo "Usage: $0 {start|stop|restart}"
    ;;
esac
```

Run in terminal:
```
./casestatement.sh start
```
```
./casestatement.sh stop
```
```
./casestatement.sh restart
```

**Example 3: File type detection with extglob (bash)**

```
touch f{1..5}
tar -czf files.tar.gz f*  
```

```
#!/usr/bin/env bash

# enable extended globbing for patterns like @(a|b|c)
shopt -s extglob

filename="$1"
case "$filename" in
  *.tar|*.tar.gz|*.tgz)
    echo "Archive file"
    ;;
  *.zip)
    echo "Zip archive"
    ;;
  *.@(jpg|jpeg|png|gif))
    echo "Image file"
    ;;
  "")
    echo "No filename provided"
    exit 2
    ;;
  *)
    echo "Unknown file type"
    ;;
esac
```

```
./case2.sh files.tar.gz 
```

---

## 6. Loops

### **for Loop**

**List Example:**
```
for fruit in apple banana cherry; do
  echo "Fruit: $fruit"
done
```

**Numeric Range Example:**
```
for i in {1..5}; do
  echo "Number: $i"
done
```

**Iterate Files in Directory:**
```
for file in *.txt; do
  echo "Found file: $file"
done
```

### **while Loop**
```
count=1
while [ $count -le 5 ]; do
  echo "Count: $count"
  ((count++))
done
```
**Wait for File Example:**
```
while [ ! -f myfile.txt ]; do
  sleep 1
done
echo "myfile.txt is now present."
```

### **until Loop**
```
count=1
until [ $count -gt 10 ]; do
  echo "Count: $count"
  ((count++))
done
```

---

## 7. Functions

**Basic Function:**
```
greet_user() {
  echo "Hello, $1 $2!"
}
greet_user "Ram" "Bahadur"
```

**Return Value Example:**
```
add_numbers() {
  local sum=$(($1 + $2))
  echo $sum
}
result=$(add_numbers 5 7)
echo "Sum is $result"
```

---

## 8. Environment Variables

### **Predefined Variables**
```
echo "User: $USER"
```
```
echo "Home: $HOME"
```
```
echo "Path: $PATH"
```
```
echo "Script name: $0"
```
```
echo "First argument: $1"
```
```
echo "Number of arguments: $#"
```
```
echo "All arguments: $@"
```

### **Export Variables (for subprocesses)**
```
export MY_VAR="value"
```
```
bash -c 'echo $MY_VAR'
```

---

## 9. I/O Redirection and Pipelines

### **Redirection**

Overwrite file:
```
echo "Hello" > output.txt
```

Append to file:
```
echo "World" >> output.txt
```

Read from file:
```
cat < input.txt
```

Redirect stderr:
```
ls /nonexistent 2> error.log
```

Redirect stdout and stderr:
```
ls /nonexistent &> all.log
```

Send output to null (ignore output):
```
command > /dev/null 2>&1
```

### **Pipelines**

Chain commands:
```
ls -l | grep ".txt" | wc -l
```
```
cat /etc/passwd | grep "/bin/bash"
```
```
ps aux | sort -rk 3,3 | head -n 5
```
```
df -h | grep "/dev/sda"
```

---

## 10. Debugging Scripts

Enable debug mode to trace execution:
```
bash -x myscript.sh
```

Add set -x inside the script for partial tracing:
```
#!/bin/bash
set -x
echo "Debugging enabled"
ls
set +x
echo "Debugging disabled"
```

---

## 11. Script Arguments

Access script arguments:
```
echo "First argument: $1"
echo "Second argument: $2"
echo "Number of arguments: $#"
echo "All arguments: $@"
```

Loop through all arguments:
```
for arg in "$@"; do
  echo "Arg: $arg"
done
```

---

## 12. Exit Status

Check exit status of last command:
```
ls /tmp
echo $?
```
Use exit in scripts:
```
if [ ! -f "$1" ]; then
  echo "File not found!"
  exit 1
fi
```

---

**Tip:** Practice scripting in a test environment. Use `man bash` and `help <command>` for more details.
