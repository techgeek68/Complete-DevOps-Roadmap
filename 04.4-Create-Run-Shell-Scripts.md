# 6. Creating and Running Bash Shell Scripts

---

Bash scripting is a foundational skill for DevOps engineers, enabling automation, orchestration, system monitoring, rapid troubleshooting, CI/CD integration, and more. This guide covers practical script creation, variables, control structures, I/O, debugging, and real-world DevOps examples.

**Terminal Vs Shell**:

A shell is a command-line interpreter that provides a user interface for accessing the services of the operating system.

A terminal emulator is a program that emulates a physical terminal within a graphical or text-based environment, allowing users to interact with the shell.


| Component         | Function                                 | Examples                |
|-------------------|------------------------------------------|-------------------------|
| Shell             | Executes user commands and scripts       | bash, zsh, sh, fish     |
| Terminal Emulator | Displays shell interface, handles I/O    | GNOME Terminal, xterm   |


**What is Bash?**
- Bash (Bourne Again SHell) is one of the most widely used Unix/Linux shells.
- It supports command execution, scripting, environment management, and automation.

**Shebang Line**
- Every Bash script should start with a shebang to specify the interpreter:
```sh
#!/bin/bash
```

**Comments**
- Use `#` for comments:
```sh
# This is a comment
echo "Hello World" # Inline comment
```


---

**Constants**:

Constants are values that do not change during the execution of the script. Bash does not have native constant variables, but you can use `readonly` or `declare -r` to simulate constants.

Examples:

```bash
readonly PI=3.14159
echo $PI  # Output: 3.14159

declare -r URL="https://github.com"
echo $URL  # Output: https://github.com

# Attempting to change a constant will result in an error:
PI=3  # bash: PI: readonly variable
```

---


# Operators in Bash Scripting

Bash scripting supports a wide range of operators used for performing arithmetic, string manipulation, and testing conditions. Here’s a categorized overview of the most important operators for scripting and automation:


1. **Arithmetic Operators**
Used for numeric calculations. Often used within `$(( ... ))` or `let` command.

| Operator | Description        | Example                |
|----------|--------------------|------------------------|
| `+`      | Addition           | `echo $((2 + 3))`      |
| `-`      | Subtraction        | `echo $((5 - 1))`      |
| `*`      | Multiplication     | `echo $((4 * 2))`      |
| `/`      | Division           | `echo $((8 / 2))`      |
| `%`      | Modulus (remainder)| `echo $((7 % 3))`      |
| `**`     | Exponentiation     | `echo $((2 ** 3))`     |
| `++`     | Increment          | `((count++))`          |
| `--`     | Decrement          | `((count--))`          |


2. **Relational (Comparison) Operators**
Used for comparing numbers (within `test`, `[ ... ]`, or `[[ ... ]]`).

| Operator | Description                | Example                   |
|----------|----------------------------|---------------------------|
| `-eq`    | Equal to                   | `[ "$a" -eq "$b" ]`       |
| `-ne`    | Not equal to               | `[ "$a" -ne "$b" ]`       |
| `-lt`    | Less than                  | `[ "$a" -lt "$b" ]`       |
| `-le`    | Less than or equal to      | `[ "$a" -le "$b" ]`       |
| `-gt`    | Greater than               | `[ "$a" -gt "$b" ]`       |
| `-ge`    | Greater than or equal to   | `[ "$a" -ge "$b" ]`       |


3. **String Operators**
Used for comparing strings.

| Operator  | Description                                 | Example                          |
|-----------|---------------------------------------------|----------------------------------|
| `=` or `==` | Equal to                                 | `[ "$a" = "$b" ]`                |
| `!=`      | Not equal to                               | `[ "$a" != "$b" ]`               |
| `<`       | Less than (lexicographically)              | `[[ "$a" < "$b" ]]`              |
| `>`       | Greater than (lexicographically)           | `[[ "$a" > "$b" ]]`              |
| `-z`      | String is empty                            | `[ -z "$a" ]`                    |
| `-n`      | String is not empty                        | `[ -n "$a" ]`                    |


4. **File Test Operators**
Used to test file types and permissions.

| Operator | Description                                  | Example                        |
|----------|----------------------------------------------|--------------------------------|
| `-e`     | File exists                                  | `[ -e file.txt ]`              |
| `-f`     | File is a regular file                       | `[ -f file.txt ]`              |
| `-d`     | File is a directory                          | `[ -d /var/log ]`              |
| `-r`     | File is readable                             | `[ -r config.cfg ]`            |
| `-w`     | File is writable                             | `[ -w output.log ]`            |
| `-x`     | File is executable                           | `[ -x script.sh ]`             |


5. **Logical Operators**
Used for combining multiple conditions.

| Operator | Meaning                    | Example                              |
|----------|----------------------------|--------------------------------------|
| `&&`     | AND (both must be true)    | `[ "$a" -gt 0 ] && [ "$b" -gt 0 ]`  |
| `||`     | OR (either can be true)    | `[ "$a" -gt 0 ] || [ "$b" -gt 0 ]`  |
| `!`      | NOT (negates condition)    | `[ ! -f file.txt ]`                  |


6. **Assignment Operators**
Used to assign values to variables.

| Operator | Description                  | Example                |
|----------|------------------------------|------------------------|
| `=`      | Assign value                 | `name="devops"`        |
| `+=`     | Add and assign (arithmetic)  | `((a += 3))`           |
| `-=`     | Subtract and assign          | `((a -= 2))`           |
| `*=`     | Multiply and assign          | `((a *= 4))`           |
| `/=`     | Divide and assign            | `((a /= 2))`           |
| `%=`     | Modulus and assign           | `((a %= 3))`           |


7. **Other Useful Operators**

| Operator | Description                   | Example                    |
|----------|-------------------------------|----------------------------|
| `,`      | Sequence operator             | `{ echo A; echo B; }`      |
| `;`      | Command separator             | `cmd1; cmd2`               |
| `&`      | Run in background             | `./script.sh &`            |
| `|`      | Pipe output                   | `ls | grep txt`            |
| `>`      | Redirect output (overwrite)   | `ls > files.txt`           |
| `>>`     | Redirect output (append)      | `echo "hi" >> log.txt`     |
| `<`      | Redirect input                | `cat < file.txt`           |

---


# Data Types

Data types represent the kind of values a variable can store. In Bash, all variables are treated as strings by default, but you can work with integers, floating-point numbers (with external tools), and simulate booleans.

**Common Data Types in Bash:**
 - **Integer:** Whole numbers (e.g., 5, -10)
 - **Float:** Decimal numbers (not natively supported, but can use `bc` or `awk`)
 - **String:** Sequence of characters
 - **Boolean:** Simulated using integers (0 for true, 1 for false) or strings ("true"/"false")

**Examples:**

**Integer:**
```bash
num=10
let "result = num + 5"
echo $result  # Output: 15
```

**Float:**
```bash
float_result=$(echo "3.14 + 2.71" | bc)
echo $float_result  # Output: 5.85
```

**String:**
```bash
name="Alice"
echo "Hello, $name!"  # Output: Hello, Alice!
```

**Boolean (simulated):**
```bash
is_valid=true
if [ "$is_valid" = "true" ]; then
    echo "Valid!"
fi
```

---

**Expressions**:

Expressions in Bash combine variables, constants, and operators to produce a value. They are used for calculations, comparisons, and string operations.

**Examples:**

**Arithmetic Expressions:**
```bash
a=5
b=3
sum=$((a + b))
echo $sum  # Output: 8
```

**String Expressions:**
```bash
str1="Hello"
str2="World"
message="$str1, $str2!"
echo $message  # Output: Hello, World!
```

**Logical Expressions:**
```bash
x=10
y=20
if [[ $x -lt $y && $y -gt 15 ]]; then
    echo "Condition met!"
fi
```

---


## Variables:
Variables are used to store data that can be referenced and manipulated throughout a script. Bash variables are untyped, meaning they can hold various types of data such as numbers, characters, or strings.

Defining variables:
          `variable_name=value`
Calling variables:
          `echo $<variable_name>`
        
**Rules**
- **No spaces around `=`:** Write assignments without spaces (e.g., `my_variable="Hello"` not `my_variable = "Hello"`).
  
- **Quoting values with spaces:** Use single or double quotes if the value includes spaces (e.g., `my_string="Hello World"`).
  
- **Naming conventions:**
  * Use letters, numbers, and underscores only.
  * Do not start with a number.
  * Variable names are **case-sensitive** (`myVar` ≠ `myvar`).


**Common Environmental Variables**
```sh
echo $HOME      # Home directory
echo $USER      # Current user
echo $PATH      # Executable search path
echo $SHELL     # Default shell
echo $PWD       # Present working directory
```

**Local Variables**:
A local variable in Bash is a variable that is defined and used only within the current shell or script (not inherited by subprocesses unless exported). Just assign with `variable=value` for a local variable in scripts or shell.

Examples:

```sh
name="phpdev"
echo "Hello, $name"
```

```sh
count=10
echo "Count is $count"
```

```sh
app="nginx"
echo "App: $app"
```

**Scope in Functions:**
Inside a function, you can use local to restrict the variable's scope.

Example:
```sh
my_func() {
  local temp="temporary value"
  echo "$temp"
}
my_func
# echo "$temp"  # This would be empty outside the function
```

**Interactive scripts**

```sh
read -p "Enter target hostname: " host
echo "Target is $host"
```

```sh
read -sp "Enter your secret: " secret
echo -e "\nSecret captured."
```
```
echo $secret 
```


| Option | Command        | Purpose                                  |
|--------|----------------|------------------------------------------|
| `-s`   | `read`         | Silent (hide user input)                 |
| `-p`   | `read`         | Prompt (show message before input)       |
| `-e`   | `echo`         | Enable backslash escape interpretation   |

---

## 2. Creating and Running a Script

**Basic Script Structure**

Create a new file:
```
vim scriptexample.sh
```

Script content:
```
#!/bin/bash
echo "This is my first script!"
pwd
```

Make executable:
```
chmod +x scriptexample.sh
```

Run:
```
./scriptexample.sh
```

---

## 3. Setting Scripts on the PATH

**Make Scripts Globally Available**

Create a new file:
```sh
vim deploy.sh
```

Sample script:
```sh
# Prompt for env if not set
if [ -z "$env" ]; then
  read -p "Enter environment (e.g. prod): " env
fi
echo "Deploying to $env environment"
```

Create a directory for custom scripts:
```sh
mkdir ~/bin
mv deploy.sh ~/bin/
cd ~/bin
chmod +x deploy.sh
```

Add to PATH in `.bashrc`:
```sh
echo 'export PATH=$PATH:~/bin' >> ~/.bashrc
```
```sh
source ~/.bashrc
```
```
cd
```
```sh
deploy.sh
```

**System-wide for all system users**
```
vim /etc/profile
```
Add:
```
export PATH=$PATH:~/<script_name>
```
Reload:
```
source /etc/profile
```

---

## 4. Conditionals: Automation & Safety

**if Statement**
In Bash scripting, the if statement allows for a conditional execution of commands based on the evaluation of a condition.

Syntax: 
```sh
if [ condition ]; then
  # commands if condition is true
fi
```

Example:
```
read -p "Enter your age: " age
if [ $age -ge 18 ]; then
  echo "You are an adult."
elif [ $age -ge 13 ]; then
  echo "You are a teenager."
else
  echo "You are a child."
fi
```

#### **String Comparison Example**
```
read -p "Enter yes or no: " answer
if [ "$answer" = "yes" ]; then
  echo "Affirmative."
else
  echo "Negative or unknown."
fi
```

### **case Statement**
```
case $1 in
  start)
    echo "Starting service..."
    ;;
  stop)
    echo "Stopping service..."
    ;;
  restart)
    echo "Restarting service..."
    ;;
  *)
    echo "Usage: $0 {start|stop|restart}"
    ;;
esac
```

Run in terminal:
```
./casestatement.sh start
```
```
./casestatement.sh stop
```
```
./casestatement.sh restart
```

---

## 6. Loops

### **for Loop**

**List Example:**
```
for fruit in apple banana cherry; do
  echo "Fruit: $fruit"
done
```

**Numeric Range Example:**
```
for i in {1..5}; do
  echo "Number: $i"
done
```

**Iterate Files in Directory:**
```
for file in *.txt; do
  echo "Found file: $file"
done
```

### **while Loop**
```
count=1
while [ $count -le 5 ]; do
  echo "Count: $count"
  ((count++))
done
```
**Wait for File Example:**
```
while [ ! -f myfile.txt ]; do
  sleep 1
done
echo "myfile.txt is now present."
```

### **until Loop**
```
count=1
until [ $count -gt 10 ]; do
  echo "Count: $count"
  ((count++))
done
```

---

## 7. Functions

**Basic Function:**
```
greet_user() {
  echo "Hello, $1 $2!"
}
greet_user "Ram" "Bahadur"
```

**Return Value Example:**
```
add_numbers() {
  local sum=$(($1 + $2))
  echo $sum
}
result=$(add_numbers 5 7)
echo "Sum is $result"
```

---

## 8. Environment Variables

### **Predefined Variables**
```
echo "User: $USER"
```
```
echo "Home: $HOME"
```
```
echo "Path: $PATH"
```
```
echo "Script name: $0"
```
```
echo "First argument: $1"
```
```
echo "Number of arguments: $#"
```
```
echo "All arguments: $@"
```

### **Export Variables (for subprocesses)**
```
export MY_VAR="value"
```
```
bash -c 'echo $MY_VAR'
```

---

## 9. I/O Redirection and Pipelines

### **Redirection**

Overwrite file:
```
echo "Hello" > output.txt
```

Append to file:
```
echo "World" >> output.txt
```

Read from file:
```
cat < input.txt
```

Redirect stderr:
```
ls /nonexistent 2> error.log
```

Redirect stdout and stderr:
```
ls /nonexistent &> all.log
```

Send output to null (ignore output):
```
command > /dev/null 2>&1
```

### **Pipelines**

Chain commands:
```
ls -l | grep ".txt" | wc -l
```
```
cat /etc/passwd | grep "/bin/bash"
```
```
ps aux | sort -rk 3,3 | head -n 5
```
```
df -h | grep "/dev/sda"
```

---

## 10. Debugging Scripts

Enable debug mode to trace execution:
```
bash -x myscript.sh
```

Add set -x inside the script for partial tracing:
```
#!/bin/bash
set -x
echo "Debugging enabled"
ls
set +x
echo "Debugging disabled"
```

---

## 11. Script Arguments

Access script arguments:
```
echo "First argument: $1"
echo "Second argument: $2"
echo "Number of arguments: $#"
echo "All arguments: $@"
```

Loop through all arguments:
```
for arg in "$@"; do
  echo "Arg: $arg"
done
```

---

## 12. Exit Status

Check exit status of last command:
```
ls /tmp
echo $?
```
Use exit in scripts:
```
if [ ! -f "$1" ]; then
  echo "File not found!"
  exit 1
fi
```

---

**Tip:** Practice scripting in a test environment. Use `man bash` and `help <command>` for more details.
