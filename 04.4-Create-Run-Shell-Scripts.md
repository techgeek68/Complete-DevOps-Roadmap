# 6. Creating and Running Bash Shell Scripts

---

Bash scripting is a foundational skill for DevOps engineers, enabling automation, orchestration, system monitoring, rapid troubleshooting, CI/CD integration, and other key tasks. This guide covers practical script creation, variables, control structures, I/O, debugging, and real-world DevOps examples.

---

**Terminal vs Shell**:

- Shell: command-line interpreter that runs commands and scripts (bash, zsh, sh, fish).
- Terminal emulator: a program that hosts the shell (GNOME Terminal, xterm, iTerm2).

| Component         | Function                                 | Examples                |
|-------------------|------------------------------------------|-------------------------|
| Shell             | Executes user commands and scripts       | bash, zsh, sh, fish     |
| Terminal Emulator | Displays shell interface, handles I/O    | GNOME Terminal, xterm   |

Common shells:
- Bourne (sh): original Unix shell—basic, reliable.
- C shell (csh): C-like syntax; interactive use.
- Korn (ksh): mixes sh and csh; script-friendly.
- Bash: enhanced sh with history, completion, and arrays.


**What is Bash and Why Use It**
- Bash (Bourne Again SHell) Bash is the common command-line shell on Unix/Linux that lets you run commands and write scripts to automate tasks.
- Portable scripts, rich control flow, integrates with Unix tools, great for automation/CI/CD.

**Shebang Line**
- Every Bash script should start with a shebang to specify the interpreter:
```sh
#!/bin/bash
```

**Comments**
- Use `#` for comments:
```sh
# This is a comment
echo "Hello World" # Inline comment
```

---

**Constants**:

Constants are values that do not change during the execution of the script. Bash does not have native constant variables, but you can use `readonly` or `declare -r` to simulate constants.

Examples:

```bash
readonly PI=3.14159
echo $PI  # Output: 3.14159
```

```bash
declare -r MAX_USERS=100
echo "Max users allowed: $MAX_USERS"
```

```bash
declare -r URL="https://github.com"
echo $URL  # Output: https://github.com
```

*Attempting to change a constant will result in an error:*
```bash
PI=3  # bash: PI: readonly variable
```

<img width="644" height="207" alt="Screenshot 2025-10-19 at 8 07 17 AM" src="https://github.com/user-attachments/assets/e7f8e03f-5d5c-4b29-92b1-3642257bd539" />


---


# Operators in Bash Scripting

Bash scripting supports a wide range of operators used for performing arithmetic, string manipulation, and testing conditions. Here’s a categorized overview of the most important operators for scripting and automation:


1. **Arithmetic Operators**
Used for numeric calculations. Often used within `$(( ... ))` or `let` command.

| Operator | Description        | Example                |
|----------|--------------------|------------------------|
| `+`      | Addition           | `echo $((2 + 3))`      |
| `-`      | Subtraction        | `echo $((5 - 1))`      |
| `*`      | Multiplication     | `echo $((4 * 2))`      |
| `/`      | Division           | `echo $((8 / 2))`      |
| `%`      | Modulus (remainder)| `echo $((7 % 3))`      |
| `**`     | Exponentiation     | `echo $((2 ** 3))`     |
| `++`     | Increment          | `((count++))`          |
| `--`     | Decrement          | `((count--))`          |


2. **Relational (Comparison) Operators**
Used for comparing numbers (within `test`, `[ ... ]`, or `[[ ... ]]`).

| Operator | Description                | Example                   |
|----------|----------------------------|---------------------------|
| `-eq`    | Equal to                   | `[ "$a" -eq "$b" ]`       |
| `-ne`    | Not equal to               | `[ "$a" -ne "$b" ]`       |
| `-lt`    | Less than                  | `[ "$a" -lt "$b" ]`       |
| `-le`    | Less than or equal to      | `[ "$a" -le "$b" ]`       |
| `-gt`    | Greater than               | `[ "$a" -gt "$b" ]`       |
| `-ge`    | Greater than or equal to   | `[ "$a" -ge "$b" ]`       |


3. **String Operators**
Used for comparing strings.

| Operator  | Description                                 | Example                          |
|-----------|---------------------------------------------|----------------------------------|
| `=` or `==` | Equal to                                 | `[ "$a" = "$b" ]`                |
| `!=`      | Not equal to                               | `[ "$a" != "$b" ]`               |
| `<`       | Less than (lexicographically)              | `[[ "$a" < "$b" ]]`              |
| `>`       | Greater than (lexicographically)           | `[[ "$a" > "$b" ]]`              |
| `-z`      | String is empty                            | `[ -z "$a" ]`                    |
| `-n`      | String is not empty                        | `[ -n "$a" ]`                    |


4. **File Test Operators**
Used to test file types and permissions.

| Operator | Description                                  | Example                        |
|----------|----------------------------------------------|--------------------------------|
| `-e`     | File exists                                  | `[ -e file.txt ]`              |
| `-f`     | File is a regular file                       | `[ -f file.txt ]`              |
| `-d`     | File is a directory                          | `[ -d /var/log ]`              |
| `-r`     | File is readable                             | `[ -r config.cfg ]`            |
| `-w`     | File is writable                             | `[ -w output.log ]`            |
| `-x`     | File is executable                           | `[ -x script.sh ]`             |


5. **Logical Operators**
Used for combining multiple conditions.

| Operator | Meaning                    | Example                              |
|----------|----------------------------|--------------------------------------|
| `&&`     | AND (both must be true)    | `[ "$a" -gt 0 ] && [ "$b" -gt 0 ]`   |
| `\|\|`     | OR (either can be true)  | `[ "$a" -gt 0 ] \|\| [ "$b" -gt 0 ]` |
| `!`      | NOT (negates condition)    | `[ ! -f file.txt ]`                  |


6. **Assignment Operators**
Used to assign values to variables.

| Operator | Description                  | Example                |
|----------|------------------------------|------------------------|
| `=`      | Assign value                 | `name="devops"`        |
| `+=`     | Add and assign (arithmetic)  | `((a += 3))`           |
| `-=`     | Subtract and assign          | `((a -= 2))`           |
| `*=`     | Multiply and assign          | `((a *= 4))`           |
| `/=`     | Divide and assign            | `((a /= 2))`           |
| `%=`     | Modulus and assign           | `((a %= 3))`           |


7. **Other Useful Operators**

| Operator | Description                   | Example                    |
|----------|-------------------------------|----------------------------|
| `,`      | Sequence operator             | `{ echo A; echo B; }`      |
| `;`      | Command separator             | `cmd1; cmd2`               |
| `&`      | Run in background             | `./script.sh &`            |
| `\|`      | Pipe output                  | `ls \| grep txt`            |
| `>`      | Redirect output (overwrite)   | `ls > files.txt`           |
| `>>`     | Redirect output (append)      | `echo "hi" >> log.txt`     |
| `<`      | Redirect input                | `cat < file.txt`           |

---


# Data Types

Data types represent the kind of values a variable can store. In Bash, all variables are treated as strings by default, but you can work with integers, floating-point numbers (with external tools), and simulate booleans.

**Common Data Types in Bash:**
 - **Integer:** Whole numbers (e.g., 5, -10)
 - **Float:** Decimal numbers (not natively supported, but can use `bc` or `awk`)
 - **String:** Sequence of characters
 - **Boolean:** Simulated using integers (0 for true, 1 for false) or strings ("true"/"false")

**Examples:**

**Integer:**
```bash
num=10
let "result=num + 5"
echo $result
```

<img width="657" height="120" alt="Screenshot 2025-10-19 at 8 09 03 AM" src="https://github.com/user-attachments/assets/fdec9779-d2eb-4f90-91ee-a8c3c0ba9c50" />

**Float:**
```bash
float_result=$(echo "3.14 + 2.71" | bc)
echo $float_result  # Output: 5.85
```

**String:**
```bash
name="Alice"
echo "Hello, $name!"  # Output: Hello, Alice!
```

**Boolean (simulated):**
```bash
is_valid=true
if [ "$is_valid" = "true" ]; then
    echo "Valid!"
fi
```

---

**Expressions**:

Expressions in Bash combine variables, constants, and operators to produce a value. They are used for calculations, comparisons, and string operations.

**Examples:**

**Arithmetic Expressions:**
```bash
a=5
b=3
sum=$((a + b))
echo $sum 
```

<img width="664" height="132" alt="Screenshot 2025-10-19 at 8 14 14 AM" src="https://github.com/user-attachments/assets/146f14e3-18f0-42f0-bdd2-183fd547b0d5" />


**String Expressions:**
```bash
str1="Hello"
str2="World"
message="$str1, $str2!"
echo $message
```

<img width="535" height="156" alt="Screenshot 2025-10-19 at 8 16 10 AM" src="https://github.com/user-attachments/assets/7a6e10ee-6e59-4ca1-a086-85db5c17291c" />


**Logical Expressions:**
```bash
x=10
y=20
if [ "$x" -lt "$y" ] && [ "$y" -gt 15 ]; then
  echo "Condition met!"
fi
```

<img width="660" height="152" alt="Screenshot 2025-10-19 at 8 27 46 AM" src="https://github.com/user-attachments/assets/2fa01c51-d57f-4896-acfa-700c39281000" />

> will print: Condition met!
> Why? because both conditions are true (10 < 20 and 20 > 15).

---


## Variables:
Variables are used to store data that can be referenced and manipulated throughout a script. Bash variables are untyped, meaning they can hold various types of data such as numbers, characters, or strings.
Defining variables:
          `variable_name=value`
Calling variables:
          `echo $<variable_name>`
        
**Rules**
- **No spaces around `=`:** Write assignments without spaces (e.g., `my_variable="Hello"` not `my_variable = "Hello"`).
  
- **Quoting values with spaces:** Use single or double quotes if the value includes spaces (e.g., `my_string="Hello World"`).
  
- **Naming conventions:**
  * Use letters, numbers, and underscores only.
  * Do not start with a number.
  * Variable names are case-sensitive (`myVar` ≠ `myvar`).


**Common Environmental Variables**
```sh
echo $HOME      # Home directory
echo $USER      # Current user
echo $PATH      # Executable search path
echo $SHELL     # Default shell
echo $PWD       # Present working directory
```

<img width="770" height="209" alt="Screenshot 2025-10-19 at 8 42 45 AM" src="https://github.com/user-attachments/assets/38ae1437-ad70-45bf-ba36-d4bc84327cac" />


**Export Variables (for subprocesses)**
```
export MY_VAR="value"
```
```
bash -c 'echo $MY_VAR'
```

**Example:**
```
# set and export
export MY_VAR="hello"
```

```
# child shell inherits exported variable
bash -c 'echo "child sees: $MY_VAR"'
```


**Local Variables**:
A local variable in Bash is a variable that is defined and used only within the current shell or script (not inherited by subprocesses unless exported). Just assign with `variable=value` for a local variable in scripts or shell.

Examples:

```sh
name="phpdev"
echo "Hello, $name"
```

```sh
count=10
echo "Count is $count"
```

```sh
app="nginx"
echo "App: $app"
```

**Scope in Functions:**
Inside a function, you can use local to restrict the variable's scope.

Example:
```sh
my_func() {
  local temp="temporary value"
  echo "$temp"
}
```
```sh
my_func
```
echo "$temp"     #This would be empty outside the function

<img width="764" height="192" alt="Screenshot 2025-10-19 at 8 47 48 AM" src="https://github.com/user-attachments/assets/aaf46a5e-d484-41dd-9f1b-7a56e8500899" />


**Interactive scripts**

```sh
read -p "Enter target hostname: " host
echo "Target is $host"
```

```sh
read -sp "Enter your secret: " secret
echo -e "\nSecret captured."
```
```
echo $secret 
```

<img width="769" height="159" alt="Screenshot 2025-10-19 at 8 51 47 AM" src="https://github.com/user-attachments/assets/d182bdd0-8145-47a7-ae39-cddbed7aa2a8" />



| Option | Command        | Purpose                                  |
|--------|----------------|------------------------------------------|
| `-s`   | `read`         | Silent (hide user input)                 |
| `-p`   | `read`         | Prompt (show message before input)       |
| `-e`   | `echo`         | Enable backslash escape interpretation   |


---


## 2. Creating and Running a Script

**Basic Script Structure**

Example:

Create a new file:
```
vim scriptexample.sh
```

Script content:
```
#!/bin/bash
echo "This is my first script!"
echo "and my current working directory is" $PWD
```

Make executable:
```
chmod +x scriptexample.sh
```

Run:
```
./scriptexample.sh
```

<img width="767" height="114" alt="Screenshot 2025-10-19 at 8 58 31 AM" src="https://github.com/user-attachments/assets/c7955497-07c2-43d9-86b6-d5a50a465ee6" />


---

## 3. Setting Scripts on the PATH

**Make Scripts Globally Available**

Example:
Create a new file:
```sh
vim deploy.sh
```

Sample script:
```sh
if [ -z "$env" ]; then
  read -p "Enter environment (e.g. prod): " env
fi
echo "Deploying to $env environment"
```

Create a directory for custom scripts:
```sh
mkdir ~/bin
mv deploy.sh ~/bin/
cd ~/bin
chmod +x deploy.sh
```

Add to PATH in `.bashrc`:
```sh
echo 'export PATH=$PATH:~/bin' >> ~/.bashrc
```
```sh
source ~/.bashrc
```
```
cd
```
```sh
deploy.sh
```


<img width="755" height="262" alt="Screenshot 2025-10-19 at 11 15 44 AM" src="https://github.com/user-attachments/assets/4e4079f0-111a-4aeb-82af-073a26deb81d" />



**System-wide for all system users**
```
vim /etc/profile
```
Add:
```
export PATH=$PATH:~/<script_name>
```
Reload:
```
source /etc/profile
```

---


## 4. Control Structure:
 Control structures determine the flow of execution in a script based on conditions or iteration. In Bash:
 - A command’s exit status (0 = success/true, nonzero = failure/false) drives most conditionals.
 - Conditions often execute real commands (e.g., `grep`, `test`) rather than only boolean expressions.
 - Tests can be done with [ ... ] `POSIX test` , [[ ... ]] `Extended test` (Bash-specific), or (( ... )) `Arithmetic `.


**Core Rules and Concepts**:

**- Exit status:**
  - `if cmd; then ... fi` runs the “then” block if `cmd` returns 0.
  - Use `set -euo pipefail` in production scripts, but understand its caveats (see Pitfalls).
  
**- Testing syntaxes:**
  - POSIX test: `[ expression ]` (aka `test`). Quote variables: `"$var"`.
  - Bash test: `[[ expression ]]` (safer, no word-splitting/globbing; supports patterns and regex).
  - Arithmetic: `(( expression ))` (integers only; returns 0 if expression ≠ 0).
  
**- String vs integer:**
  - Strings: `=` `!=` (POSIX), `<` `>` in `[[ ... ]]` are lexicographic; in `[ ... ]`, `<` `>` are redirections—must escape or avoid.
  - Integers: `-eq` `-ne` `-lt` `-le` `-gt` `-ge` or use arithmetic context `(( a < b ))`.
  
**- File tests (common):**
  - `-e` exists, `-f` regular file, `-d` directory, `-s` size > 0
  - `-r` readable, `-w` writable, `-x` executable, `-L` symlink
  - `file1 -nt file2` newer-than, `file1 -ot file2` older-than
  
**- Patterns and regex:**
  - Glob patterns: `[[ $v == pat* ]]` and `case` use globs (`* ? [ ]`).
  - Regex: `[[ $v =~ ^re$ ]]` uses ERE; the right-hand side should be unquoted. Capture groups: `${BASH_REMATCH[n]}`.
  
**- Quoting:**
  - Always quote variables in commands and in `[ ... ]`: `"$var"`.
  - In `[[ ... ]]`, unquoted variables won’t word-split or glob, but quote when you need literal matching.
  
**- Arithmetic context specifics:**
  - `(( ... ))` treats unset vars as 0 (even under `set -u`), which can hide bugs—initialize explicitly.
  
**- Loop control depth:**
  - `break [n]` and `continue [n]` accept a numeric level for nested loops. `continue 2` advances the next iteration of the 2nd enclosing loop.

**Portability note:**
- Prefer `[ ... ]` and avoid Bash-only features if targeting `/bin/sh`.
- `[[ ... ]]`, `(( ... ))`, `=~`, `;;&`, `;&`, and `select` are Bash-specific.


**Control Structures**:
```
│
├─ 1. Conditional Statements
│    ├─ if / elif / else
│    └─ switch / case
│
├─ 2. Looping Constructs
│    ├─ for
│    ├─ while
│    └─ until
│
└─ 3. Loop Control Statements
     ├─ break
     └─ continue
```

**if Statement**
In Bash scripting, the if statement enables the conditional execution of commands based on the evaluation of a condition.

**Syntax:**

**if / elif / else**

```sh
if [ condition ]; then
  # commands if condition is true
fi
```

```sh
if command; then
  # commands when the command exit status is 0
elif other_command; then
  # ...
else
  # ...
fi
```

**Examples**:


**Example 1**
```bash
#!/bin/bash
# Simple script demonstrating different types of tests in Bash

# Set example variables
path="/etc/passwd"
x=15

# POSIX-style test using [ ]
if [ -f "$path" ] && [ -r "$path" ]; then
  echo "Readable file"
fi

# Bash-style test using [[ ]]
if [[ -f $path && -r $path ]]; then
  echo "Readable file (Bash)"
fi

# Arithmetic comparison using (( ))
if (( x > 10 )); then
  echo "x is greater than 10"
fi
```

<img width="744" height="152" alt="Screenshot 2025-10-19 at 1 02 57 PM" src="https://github.com/user-attachments/assets/a36ef7c5-709b-450e-abda-83ec5c4f3245" />

**Example 2**
```
read -p "Enter your age: " age
if [ $age -ge 18 ]; then
  echo "You are an adult."
elif [ $age -ge 13 ]; then
  echo "You are a teenager."
else
  echo "You are a child."
fi
```

<img width="747" height="339" alt="Screenshot 2025-10-19 at 1 04 44 PM" src="https://github.com/user-attachments/assets/20a2c18b-5961-43ad-8b2e-c6495bfc2c86" />

**Example 3**
```
read -p "Enter yes or no: " answer
if [ "$answer" = "yes" ]; then
  echo "Affirmative."
else
  echo "Negative or unknown."
fi
```

<img width="743" height="185" alt="Screenshot 2025-10-19 at 1 08 08 PM" src="https://github.com/user-attachments/assets/0dd2a371-3621-41f6-8a32-51d14a401fe0" />


### **case Statement**

- The case statement is a multi-way branch that matches a single word/string against one or more shell glob patterns.
- Use it for command dispatch, option parsing, filename/type handling, interactive prompts, and any situation where you need pattern-based branching.
- Patterns are shell globs (not regular expressions).

Syntax:
```
case "$word" in
  pattern1)
    commands
    ;;
  pattern2|alt)
    commands
    ;;
  "")
    commands_for_empty_string
    ;;
  *)
    default_commands
    ;;
esac
```

Quote the word: 
 - case "$word" in … to handle empty strings and whitespace safely.
 - Each pattern ends with ) and the block ends with ;;.
    - is the default branch if nothing else matches.
   
Pattern rules (globs):
- matches any string (including empty).
- ? matches any single character.
- [abc] matches one character from the class; [a-z] is a range.
- [!a-z] or [^a-z] (shell variant) matches negation inside [].
- Use | to separate alternatives in one case pattern: start|begin)
- Patterns are matched in order; the first matching pattern is taken (unless using bash fall-through extensions described below).
- Patterns are glob-based; they do not support regex constructs like +, {n}, or anchors.

**Examples**

**Example 1: Confirmation prompt**

```
vim confirmation.sh
```
```
#!/usr/bin/env bash

read -p "Remove all logs? (y/N): " ans
case "$ans" in
  y|Y|yes|Yes)
    echo "Removing logs..."
    # rm -rf /var/log/myapp/*.log
    ;;
  n|N|no|No|"")
    echo "Aborted."
    ;;
  *)
    echo "Please answer yes or no."
    ;;
esac
```
```
chmod +x confirmation.sh
```
```
./confirmation.sh
```

<img width="786" height="162" alt="Screenshot 2025-10-26 at 10 47 25 AM" src="https://github.com/user-attachments/assets/2fded4b4-0477-4a2e-9a5e-ae94aa90b37d" />


**Example 2:Basic command dispatch (service script)**

```
vim case.sh
```

```
case $1 in
  start)
    echo "Starting service..."
    ;;
  stop)
    echo "Stopping service..."
    ;;
  restart)
    echo "Restarting service..."
    ;;
  *)
    echo "Usage: $0 {start|stop|restart}"
    ;;
esac
```

Run in terminal:
```
./case.sh start
```
```
./case.sh stop
```
```
./case.sh restart
```

<img width="803" height="166" alt="Screenshot 2025-10-26 at 10 50 22 AM" src="https://github.com/user-attachments/assets/360263b5-e161-4800-9c32-be3972cd6d9f" />


**Example 3: File type detection with extglob (bash)**

```
touch f{1..5}
tar -czf files.tar.gz f*  
```

```
#!/usr/bin/env bash

# enable extended globbing for patterns like @(a|b|c)
shopt -s extglob

filename="$1"
case "$filename" in
  *.tar|*.tar.gz|*.tgz)
    echo "Archive file"
    ;;
  *.zip)
    echo "Zip archive"
    ;;
  *.@(jpg|jpeg|png|gif))
    echo "Image file"
    ;;
  "")
    echo "No filename provided"
    exit 2
    ;;
  *)
    echo "Unknown file type"
    ;;
esac
```

```
./case2.sh files.tar.gz 
```

<img width="731" height="119" alt="Screenshot 2025-10-26 at 10 48 21 AM" src="https://github.com/user-attachments/assets/9615981a-c01f-4ee7-9f67-153fef5316bf" />

---

## 6. Loops

- Loops let you repeatedly run commands while a condition holds (while/until) or iterate over a list (for).
- Use loops for file-processing, iterating arrays, polling/waiting, numeric iteration, and more.
- Be mindful of quoting, word-splitting, IFS, and subshells — these are common sources of bugs.

### **for Loop**

- Iterates over a list of words or array elements.
- Basic word-list form (safe with quoting): for item in a b c; do ...; done

**Examples**

**Example 1:Basic list iteration**
```
vim fruit.sh
```
```
for fruit in apple banana cherry; do
  echo "Fruit: $fruit"
done
```
```
chmod +x fruit.sh
```
```
./fruit.sh
```

<img width="803" height="144" alt="Screenshot 2025-10-26 at 11 02 42 AM" src="https://github.com/user-attachments/assets/0cd1b5dd-2188-4585-8e7a-f4c4eb2cd60f" />


**Example 2:Numeric range (brace expansion; shell expands before execution)**

```
vim number.sh
```

```
for i in {1..24}; do
  echo "Number: $i"
done
```

```
chmod +x number.sh
```
```
./number.sh
```

<img width="549" height="520" alt="Screenshot 2025-10-26 at 11 15 21 AM" src="https://github.com/user-attachments/assets/117b19df-56dd-4e9e-be1a-c2eee3053617" />


**Example 3: Iterate files (careful: glob left unchanged if no matches)**

```
vim matching.sh
```
```
for file in *.txt; do
  [ -e "$file" ] || { echo "No .txt files"; break; }  # handle no-match
  echo "Found file: $file"
done
```
```
chmod +x matching.sh
```
```
touch f1.txt
```
```
./matching.sh
```

**Example 4: Iterate over an array**
```
arr=("one" "two with space" "three")
for item in "${arr[@]}"; do
  echo "Item: $item"
done
```

**Example 5: C-style numeric loop**
```
for ((i=0; i<5; i++)); do
  echo "i is $i"
done
```

**Example 6: Using break & continue**
```
for i in {1..10}; do
  if (( i == 3 )); then
    continue   # skip 3
  fi
  if (( i == 7 )); then
    break      # stop the loop entirely
  fi
  echo "Value: $i"
done
# Prints 1,2,4,5,6 then stops
```

### **while Loop**
- while: repeats the body as long as the test/command returns true (exit status 0).
- until: repeats the body until the test/command returns true (i.e., runs while the test is false).
- Use while/until for counters, polling/waiting, reading streams, processing command output, retries, and interactive loops.

**Example 1: Simple counter**
```
count=1
while [ "$count" -le 5 ]; do
  echo "Count: $count"
  count=$((count + 1))
done
```

**Example 2:Using arithmetic (( ))**
```
count=1
while (( count <= 5 )); do
  echo "Count: $count"
  ((count++))
done
```

**Example 3: Wait for File Example:**
```
#!/usr/bin/env bash
# Simple waiter: usage ./wait-for-file.sh [filename]
FILE="${1:-myfile.txt}"
echo "Waiting for $FILE..."
while [ ! -f "$FILE" ]; do
  sleep 1
done
echo "$FILE is now present."
```

- Make executable: chmod +x wait-for-file.sh
- Start: ./wait-for-file.sh
- In another terminal create the file: echo Linux > myfile.txt

### **until Loop**

```
vim until-loop.sh
```
```
#!/usr/bin/env bash
# Simple until-loop demo: usage ./until-loop.sh [max]
MAX="${1:-10}"
count=1

until [ "$count" -gt "$MAX" ]; do
  echo "Count: $count"
  ((count++))
done
```

- Make it executable (chmod +x until-loop.sh)
- Invoking ./until-loop.sh or ./until-loop.sh 20 to count to 20.

---

## 7. Functions

A function is a block of code designed to perform a specific task, which can be called and reused multiple times within a script. Functions help in organizing code, improving readability, and reducing redundancy.

Syntax:
```
    function my_function() {
        # Commands to be executed
        echo "This is my function."
    }
```

**Example 1: Basic Function (Basic greeting)**
```
greet_user() {
  echo "Hello, $1 $2!"
}
greet_user "Ram" "Bahadur"
```

**Example 2: Add numbers and return the result via stdout:**
```
add_numbers() {
  local sum=$(( $1 + $2 ))
  echo "$sum"
}
result=$(add_numbers 5 7)
echo "Sum is $result"
```

**Example 3: Return a status (0-255):**
```
is_even() {
  local n=$1
  (( n % 2 == 0 )) && return 0 || return 1
}

if is_even 4; then
  echo "even"
else
  echo "odd"
fi
```


---


## 8. Debugging Scripts

Enable debug mode to trace execution:
```
bash -x <script-name>.sh
```

Add set -x inside the script for partial tracing:
```
#!/bin/bash
set -x
echo "Debugging enabled"
ls
set +x
echo "Debugging disabled"
```

---


## 10. Exit Status

An exit status (or exit code) is a small integer that a process returns to the shell when it finishes. It tells the caller whether the command succeeded or failed (and, if it failed, roughly why).
- Convention: 0 means success. Any non‑zero value means failure/error.
- The shell stores the exit status of the last command in $?. Check it immediately after the command.

**Example**
```
ls /tmp
echo $?   # prints 0 if ls succeeded
```
```
ls /no/such/path
echo $?   # non-zero, e.g. 2
```

**Use exit in scripts-Script example**
```
 #!/usr/bin/env bash
if [ ! -f "$1" ]; then
  echo "File not found" >&2
  exit 1
fi
echo "File exists"
exit 0
```

**Use exit in pipelines**
```
set -o pipefail
cmd1 | cmd2 | cmd3
echo $?   # non-zero if any cmdN failed
```

---
