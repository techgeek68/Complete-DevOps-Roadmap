# 10. Managing Firewalls

This section covers practical Linux firewall management, opening/closing ports, and configuring security modules like SELinux and AppArmor. 

---

## 10.1 Firewall Management

A firewall is a network security system that monitors and controls incoming and outgoing network traffic based on predetermined security rules. It acts as a barrier between a trusted internal network and an untrusted external network.

In Linux, firewalls are implemented at the kernel level, primarily using the netfilter framework. The user-space tools we interact with (like iptables, nftables, ufw) are just front-ends to configure netfilter.


**iptables**:

`iptables` is the traditional, most widely known firewall administration tool for Linux. It uses tables, chains, and rules to manage packet filtering.

Key Concepts:
 - Tables: Sets of rules for different purposes.
  - `filter`: The default table, used for packet filtering (allowing/blocking).
  - `nat`: For Network Address Translation (e.g., port forwarding).
  - `mangle`: For specialized packet alteration.
    
 - Chains: Pre-defined points in the packet's journey where rules are applied.
  - `INPUT`: For packets destined *to* the local system.
  - `OUTPUT`: For packets generated *by* the local system.
  - `FORWARD`: For packets being *routed through* the local system.

 - Rules: The individual instructions that define what to do with a packet that matches specific criteria (e.g., source IP, destination port).
 
 - Targets: The action to take when a packet matches a rule.
  - `ACCEPT`: Allow the packet.
  - `DROP`: Block the packet silently (no response sent).
  - `REJECT`: Block the packet and send an error message back.
  - `LOG`: Log the packet to syslog (e.g., `/var/log/syslog`).


**Common iptables Commands:**

| Command | Description |
| :--- | :--- |
| `iptables -L` | List all rules in the filter table. |
| `iptables -L -t nat` | List all rules in the nat table. |
| `iptables -L -v` | List rules with more verbose information. |
| `iptables -F` | Flush (delete) all rules. |
| `iptables -A INPUT -p tcp --dport 22 -j ACCEPT` | **Append** a rule to the INPUT chain to allow SSH (port 22). |
| `iptables -A INPUT -p tcp --dport 80 -j ACCEPT` | Allow HTTP (port 80). |
| `iptables -A INPUT -s 192.168.1.0/24 -j DROP` | Drop all packets from a specific subnet. |
| `iptables -I INPUT 1 -i lo -j ACCEPT` | **Insert** at position 1 a rule to allow all traffic on the loopback interface. |
| `iptables -P INPUT DROP` | Set the default **policy** for the INPUT chain to DROP (block everything not explicitly allowed). |

Important Caveat:
- Rules made with `iptables` are ephemeral and will be lost on reboot.
- You must save them to a file. The method varies by distribution:
  - Debian/Ubuntu:`iptables-save > /etc/iptables/rules.v4`
  - RHEL/CentOS:`service iptables save`


_Install and Persist (CentOS/RHEL with iptables-services):_
```bash
sudo dnf install iptables-services -y  (CentOS 9 or earlier)
sudo yum install iptables-nft          (For CentOS 10 [recommended: use nftables])
systemctl enable iptables --now
```

_List all rules:_
```bash
sudo iptables -L -n -v
```

_Save rules (to persist after reboot):_
```bash
# Debian/Ubuntu
sudo iptables-save > /etc/iptables/rules.v4

# RHEL/CentOS
sudo service iptables save
```

_Allow incoming SSH (port 22):_
```bash
sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
```
- `-A INPUT`: Append rule to INPUT chain.
- `-p tcp`: Protocol TCP.
- `--dport 22`: Destination port 22 (SSH).
- `-j ACCEPT`: Accept connection.

_Allow incoming HTTP (port 80):_
```bash
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
```

_List current rules with line numbers:_
```bash
sudo iptables -L INPUT --line-numbers -n
```

_Delete a rule by number (example: delete rule 1):_
```bash
sudo iptables -D INPUT 1
```

_Block an IP address:_
```bash
sudo iptables -A INPUT -s 192.168.1.100 -j DROP
```

_Block an IP on a specific port (example: SSH):_
```bash
sudo iptables -A INPUT -s 192.168.1.100 -p tcp --dport 22 -j DROP
```

_Check if an IP is blocked:_
```bash
sudo iptables -L INPUT -n | grep 192.168.1.100
# No output → not blocked
# DROP in output → blocked
```

_Unblock an IP:_
```bash
sudo iptables -L INPUT --line-numbers -n
sudo iptables -D INPUT 3  # Example: remove rule 3
```

_Verify unblock:_
```bash
sudo iptables -L INPUT -n | grep 192.168.1.100
```

> Default deny inbound, only allow required services. Document every rule change.
> Always verify changes after modifying firewall rules. Keep a backup of your rules before making bulk changes.


**nftables: The Modern Successor**

`nftables` is the modern replacement for `iptables`, designed to overcome its limitations. It provides a simpler syntax, better performance, and unified management for IPv4 and IPv6.

**Advantages over iptables:**

*   **Simpler Syntax:** Rules are easier to read and write.
*   **Unified Framework:** A single tool replaces `iptables`, `ip6tables`, `arptables`, and `ebtables`.
*   **Better Performance:** Uses a "virtual machine" in the kernel for more efficient rule evaluation.

**Common nftables Commands & Syntax:**

First, you often work with a configuration file (`/etc/nftables.conf`) or enter commands directly.

**Example: Recreating a basic firewall with nft.**

1.  **Create a table:**
    ```bash
    sudo nft add table inet my_filter_table
    ```

2.  **Create chains within that table:**
    ```bash
     sudo nft add chain inet my_filter_table input_chain  '{ type filter hook input priority 0; policy drop; }'
     sudo nft add chain inet my_filter_table output_chain '{ type filter hook output priority 0; policy accept; }'
    ```

3.  **Add rules to the chains:**
    ```bash
    # Allow established and related traffic
    sudo nft add rule inet my_filter_table input_chain ct state established,related accept

    # Allow loopback interface (localhost)
    sudo nft add rule inet my_filter_table input_chain iifname "lo" accept

    # Allow SSH (port 22)
    sudo nft add rule inet my_filter_table input_chain tcp dport 22 accept

    # Allow HTTP (port 80)
    sudo nft add rule inet my_filter_table input_chain tcp dport 80 accept
    ```

<img width="1022" height="379" alt="Screenshot 2025-10-29 at 9 45 14 AM" src="https://github.com/user-attachments/assets/f283c745-3b9d-4cb2-bf35-14c782a026b6" />
    
4. **Verify Configuration**
```
  sudo nft list table inet my_filter_table
```

<img width="1022" height="379" alt="Screenshot 2025-10-29 at 9 45 14 AM" src="https://github.com/user-attachments/assets/f44f3f01-5773-427e-b797-c07c700bac17" />


5. **Save and make persistent**
   
Ubuntu/Debian:
```
sudo nft list ruleset > /etc/nftables.conf
sudo systemctl enable nftables
sudo systemctl start nftables
```

RedHat/CentOS/Fedora
```
sudo nft list ruleset > /etc/sysconfig/nftables.conf
sudo systemctl enable --now nftables
```


**list your rules with line numbers so you can see their order:**
sudo nft -a list chain inet my_filter_table input_chain

**delete them one by one:**
sudo nft delete rule inet my_filter_table input_chain handle 5
sudo nft delete rule inet my_filter_table input_chain handle 4


**Listing and Managing Rules:**

| Command | Description |
| :--- | :--- |
| `nft list ruleset` | List the entire active ruleset. |
| `nft flush ruleset` | Delete all rules, tables, and chains. |
| `nft list table inet my_filter_table` | List a specific table. |


---


### UFW: Uncomplicated Firewall (not available in CentOS 10)

UFW is a user-friendly front-end for `iptables` (and can use `nftables` as a backend) that simplifies the process of managing a firewall. It's the default firewall configuration tool in Ubuntu.

**Common UFW Commands:**

| Command | Description |
| :--- | :--- |
| `ufw status` | Check the status of UFW. |
| `ufw enable` | Enable the firewall. |
| `ufw disable` | Disable the firewall. |
| `ufw default deny incoming` | Set default policy to deny all incoming connections. |
| `ufw default allow outgoing` | Set default policy to allow all outgoing connections. |
| `ufw allow 22` | Allow SSH (port 22). |
| `ufw allow 80/tcp` | Allow HTTP (port 80, specifically TCP). |
| `ufw allow from 192.168.1.100` | Allow all ports from a specific IP. |
| `ufw deny 23` | Block Telnet (port 23). |
| `ufw delete allow 22` | Delete the rule that allows SSH. |


**Examples**

_Enable UFW:_
```bash
sudo ufw enable
```

_Allow SSH:_
```bash
sudo ufw allow ssh
```

_Open port 443 (HTTPS):_
```bash
sudo ufw allow 443/tcp
```

_Deny port 21 (FTP):_
```bash
sudo ufw deny 21
```

_Check status:_
```bash
sudo ufw status verbose
```

_Block an IP:_
```bash
sudo ufw deny from 192.168.1.50
```

> Use service names for common ports. For anything custom, specify port/protocol.
> UFW rules are stored in `/etc/ufw/` and are automatically applied on boot.


---


**firewalld**:

firewalld is the default firewall management tool in RHEL, CentOS, Fedora, and other distributions. Its key feature is being "dynamic," meaning rules can be changed without restarting the firewall or breaking existing connections.

 - Zones
  - Pre-defined sets of rules (trust levels) like home, public, internal.

 - Services
  - Pre-defined rules for common services (e.g., ssh, http).

 - Runtime vs. Permanent
  - Runtime changes take effect immediately but are lost on reboot. Permanent changes are saved to the configuration and loaded on boot.


**Common firewalld Commands (`firewall-cmd`):**

| Command | Description |
| :--- | :--- |
| `firewall-cmd --state` | Check if firewalld is running. |
| `firewall-cmd --get-active-zones` | See the active zones. |
| `firewall-cmd --list-all` | List rules for the default zone. |
| `firewall-cmd --list-all --zone=public` | List rules for a specific zone. |
| `firewall-cmd --add-service=http --permanent` | Permanently allow HTTP service. |
| `firewall-cmd --add-port=8080/tcp --permanent` | Permanently allow a custom port. |
| `firewall-cmd --reload` | Reload the firewall (applies permanent rules without a full restart). |
| `firewall-cmd --runtime-to-permanent` | Save the current runtime configuration as permanent. |


**Examples**

```bash
firewall-cmd --state
```
<img width="789" height="87" alt="Screenshot 2025-10-28 at 1 01 22 PM" src="https://github.com/user-attachments/assets/4555e25b-7f88-4e51-befc-295aaa4da32c" />


```bash
firewall-cmd --get-active-zones
```
<img width="806" height="72" alt="Screenshot 2025-10-28 at 1 02 57 PM" src="https://github.com/user-attachments/assets/3aa983b7-adff-4061-adc9-3cb4421bf6d8" />


```bash
firewall-cmd --list-all
```
<img width="841" height="293" alt="Screenshot 2025-10-28 at 1 03 53 PM" src="https://github.com/user-attachments/assets/9a44cea6-ab67-4a6b-8758-1e8e0fc244b5" />


Open HTTP (port 80) permanently:
```bash
firewall-cmd --zone=public --add-port=80/tcp --permanent
firewall-cmd --reload
firewall-cmd --list-ports
```
<img width="784" height="176" alt="Screenshot 2025-10-28 at 1 08 09 PM" src="https://github.com/user-attachments/assets/15aec5ae-59c7-4989-b732-9f444ae447ec" />


Services concept (predefined):
```bash
firewall-cmd --get-services
firewall-cmd --add-service=https --permanent
firewall-cmd --reload
```
<img width="751" height="125" alt="Screenshot 2025-10-28 at 1 10 58 PM" src="https://github.com/user-attachments/assets/1b391185-a878-41e7-ba8d-17ed0001103e" />


Enable at boot:
```bash
systemctl enable firewalld --now
```


**More Examples**

_Allow HTTP/HTTPS/SSH services:_
```bash
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --permanent --add-service=ssh
```

_Open a specific port (e.g., 8080):_
```bash
sudo firewall-cmd --permanent --add-port=8080/tcp
```

_Reload firewall (apply changes):_
```bash
sudo firewall-cmd --reload
```

<img width="899" height="486" alt="Screenshot 2025-10-29 at 10 35 08 AM" src="https://github.com/user-attachments/assets/a71c2ac5-626e-4317-ba83-4b521738694c" />


_Remove/Block a service:_
```bash
sudo firewall-cmd --permanent --remove-service=ssh
sudo firewall-cmd --reload
```

_Verify removal:_
```bash
sudo firewall-cmd --list-all
```

<img width="782" height="663" alt="Screenshot 2025-10-29 at 10 36 29 AM" src="https://github.com/user-attachments/assets/4e11cdcf-d897-4e49-8841-447115576f24" />


_Block/Unblock an IP:_
```bash
# Block a single IP
sudo firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.1.100" reject'
sudo firewall-cmd --reload
```
<img width="1025" height="65" alt="Screenshot 2025-10-29 at 10 41 11 AM" src="https://github.com/user-attachments/assets/4545fc3a-3c23-4951-b9a3-8cd3f307559e" />

<img width="1024" height="309" alt="Screenshot 2025-10-29 at 10 41 21 AM" src="https://github.com/user-attachments/assets/6c796721-3370-4b04-a571-e012c5f7dc0d" />

```bash
# Unblock
sudo firewall-cmd --permanent --remove-rich-rule='rule family="ipv4" source address="192.168.1.100" reject'
sudo firewall-cmd --reload
```
- `reject` sends "connection refused"; use `drop` for silent blocking.

_Block an IP range (CIDR):_
```bash
sudo firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.1.0/24" reject'
sudo firewall-cmd --reload
```

_Verify status:_
```bash
sudo firewall-cmd --list-services
sudo firewall-cmd --list-all
```

> Use `--permanent` for changes that need to persist after reboot. Always reload after modifying rules.


---


## Opening/Closing Ports & Services

- Prefer service names (e.g., `ssh`, `http`) to simplify rules.
- Use custom ports for unlisted services.
- Firewalld’s `--permanent` and iptables-save ensure persistence.

> Document all firewall changes for audit purposes, especially in production.


---


## SELinux and AppArmor

**A. SELinux (Security-Enhanced Linux)**

_Check status:_
```bash
sestatus
```

<img width="707" height="205" alt="Screenshot 2025-10-29 at 10 43 36 AM" src="https://github.com/user-attachments/assets/8935ae38-828d-4928-8f4a-43934ae1ac50" />

```bash
getenforce
```

<img width="745" height="58" alt="Screenshot 2025-10-29 at 10 44 50 AM" src="https://github.com/user-attachments/assets/6f6321ec-004c-4b96-91d0-3db73e0fdee3" />

- `Enforcing`: Active, blocking violations.
- `Permissive`: Logging, not blocking.
- `Disabled`: Off.

_Set mode temporarily:_

- `Permissive`: Logging, not blocking.
```bash
sudo setenforce 0      #Permissive
```
```bash

Verify:
```bash
getenforce
```

- `Enforcing`: Active, blocking violations.
```bash
sudo setenforce 1        #Enforcing
```

<img width="629" height="69" alt="Screenshot 2025-10-29 at 10 46 02 AM" src="https://github.com/user-attachments/assets/b852babc-ce52-4065-8962-2340e6ce11d0" />


_Set mode permanently:_
```bash
sudo vi /etc/selinux/config
```

<img width="707" height="801" alt="Screenshot 2025-10-29 at 10 51 48 AM" src="https://github.com/user-attachments/assets/42fc16cf-57ad-4326-833c-36e84f18f448" />


_Allow a service (HTTP on port 8080):_
```bash
sudo semanage port -a -t http_port_t -p tcp 9090
```
<img width="767" height="153" alt="Screenshot 2025-10-29 at 11 04 38 AM" src="https://github.com/user-attachments/assets/13f9f4f5-4f02-426b-aef4-6850dad1400a" />

_Allow SMTP & MySQL:_
```bash
sudo semanage port -a -t smtp_port_t -p tcp 25
sudo semanage port -a -t mysqld_port_t -p tcp 3306
```

_Verify allowed ports:_
```bash
sudo semanage port -l
sudo semanage port -l | grep mysqld
sudo semanage port -l | grep smtp
```

<img width="844" height="167" alt="Screenshot 2025-10-29 at 11 06 40 AM" src="https://github.com/user-attachments/assets/e927920b-3d3f-4dd4-a782-8a97b1961089" />


> Use Enforcing in production. Permissive is only for troubleshooting. Avoid disabling SELinux unless absolutely necessary.


---


**B. AppArmor (Debian/Ubuntu)**

_Check status:_
```bash
sudo apparmor_status
```

_Set profile mode (enforce/complain):_
```bash
sudo aa-enforce /path/to/profile
sudo aa-complain /path/to/profile
```

_Reload profiles:_
```bash
sudo systemctl reload apparmor
```

_Adjust profiles based on logs:
```bash
sudo aa-logprof
```
Profiles are located in `/etc/apparmor.d/`.

 
> Regularly review AppArmor logs for denied actions and tune profiles with `aa-logprof`.


---


## 10.2 Additional Topics for DevOps Engineers


**1. Managing Security Groups in Cloud (AWS, Azure, GCP)**

Cloud environments use Security Groups and Network ACLs that function like firewalls but are managed differently.

**AWS Example:**
```bash
# List security groups
aws ec2 describe-security-groups

# Add a rule to allow SSH
aws ec2 authorize-security-group-ingress --group-id sg-12345678 --protocol tcp --port 22 --cidr 0.0.0.0/0

# Remove a rule
aws ec2 revoke-security-group-ingress --group-id sg-12345678 --protocol tcp --port 22 --cidr 0.0.0.0/0
```
_Verifying:_
- Use AWS Console or `aws ec2 describe-security-groups` to check rules.


> Restrict access by CIDR as much as possible—never use 0.0.0.0/0 in production.


**Azure Example (using Azure CLI):**
```bash
# List NSG (Network Security Group) rules
az network nsg rule list --resource-group myResourceGroup --nsg-name myNSG

# Add a rule to allow SSH
az network nsg rule create --resource-group myResourceGroup --nsg-name myNSG --name AllowSSH --protocol tcp --direction inbound --priority 1000 --source-address-prefixes '*' --destination-port-ranges 22 --access Allow

# Remove a rule
az network nsg rule delete --resource-group myResourceGroup --nsg-name myNSG --name AllowSSH
```
_Verifying:_
- Check rules with `az network nsg rule list` or via the Azure Portal.

 
> Always set a specific source address/range (avoid '*') except for testing.


**GCP Example (using gcloud):**
```bash
# List firewall rules
gcloud compute firewall-rules list

# Add a rule to allow SSH
gcloud compute firewall-rules create allow-ssh --direction=INGRESS --priority=1000 --network=default --action=ALLOW --rules=tcp:22 --source-ranges=0.0.0.0/0

# Remove a rule
gcloud compute firewall-rules delete allow-ssh
```
_Verifying:_
- Use `gcloud compute firewall-rules list` or check in GCP Console.


> Use restrictive source ranges. Audit rules frequently in cloud environments.


---


**2. Automating Firewall Rules (Infrastructure as Code)**

DevOps engineers often manage firewall rules via automation tools.

**Example with Ansible:**
```yaml
- name: Allow HTTP with firewalld
  ansible.builtin.firewalld:
    service: http
    permanent: yes
    state: enabled
```

_Verifying:_
- Run playbook and check with `firewall-cmd --list-services`.


> Version control all infrastructure changes, including firewall rules.


---


**3. Handling Firewall Rules in Containers (Docker/Kubernetes)**

Containers have their own networking. Sometimes, you must open ports or use network policies.

**Docker Example:**
```bash
# Run container exposing port 8080
docker run -d -p 8080:8080 myapp
```
_Verifying:_
- Access with `curl localhost:8080`.


**Kubernetes Example (NetworkPolicy):**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-nginx
spec:
  podSelector:
    matchLabels:
      app: nginx
  ingress:
    - from:
        - ipBlock:
            cidr: 10.0.0.0/24
```
_Verifying:_
- Use `kubectl describe networkpolicy allow-nginx`.


> Apply least-privilege policies—only allow necessary traffic between pods/nodes.


---


**4. Port Scanning and Validation**

Knowing how to check open ports externally is important for verification.

**Example:**
```bash
# Scan open ports on localhost
nmap localhost

# Scan remote host
nmap -Pn example.com
```
_Verifying:_
- Review `nmap` results for undesired open ports.


> Regularly scan your infrastructure to catch misconfigurations.


---


**6. Overview: VPNs and Secure Remote Access**

VPNs are often used to secure connections to infrastructure.

**OpenVPN Example:**
```bash
# Connect to VPN
sudo openvpn --config client.ovpn
```
_Verifying:_
- Check with `ip a` for tun0 interface.
- Try accessing remote resources.


> Enforce multi-factor authentication (MFA) for VPN access.


---


## 10.3 Advanced Topics for DevOps Engineers

**7. Integrating Firewall Changes with CI/CD Pipelines**

Automating firewall rule changes as part of your deployment pipeline helps ensure infrastructure stays secure and compliant as code changes are released.

**Example (GitHub Actions with Ansible):**
```yaml
name: Apply Firewall Rules

on:
  push:
    branches:
      - main

jobs:
  firewall:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Ansible
        run: sudo apt-get install -y ansible
      - name: Apply Firewall Playbook
        run: ansible-playbook firewall.yml
```

_Verifying:_
- Check your infrastructure for rule application after the pipeline runs.
- Review pipeline output logs for any errors or skipped tasks.

 
> Require code review and approvals on infrastructure code changes, especially for firewall rules.


---


**8. Automated Compliance Checks**

Tools like Chef InSpec or OpenSCAP can be used to audit firewall settings and ensure they meet compliance requirements (PCI, HIPAA, etc.).

**Example (Chef InSpec):**
```ruby
describe iptables do
  it { should have_rule('-A INPUT -p tcp --dport 22 -j ACCEPT') }
  it { should_not have_rule('-A INPUT -p tcp --dport 23 -j ACCEPT') }
end
```
_Verifying:_
- Run `inspec exec <profile>` and review reports.
- Integrate compliance checks into CI/CD or scheduled jobs.

  
> Automate compliance checks and alert on deviations.


---


**9. Multi-Cloud Networking and Firewall Coordination**

In complex architectures, you may need to coordinate firewall rules across AWS, Azure, and GCP.

**Example (Terraform multi-cloud):**
```hcl
resource "aws_security_group" "web" {
  # AWS Security Group Rules...
}
resource "azurerm_network_security_group" "web" {
  # Azure NSG Rules...
}
resource "google_compute_firewall" "web" {
  # GCP Firewall Rules...
}
```
_Verifying:_
- Use each cloud's CLI or dashboard to check provisioning and rule consistency.


> Keep all infrastructure as code in a single repo or mono-repo for coordination.


---


**10. Real-World Audit, Reporting, and Alerting**

Set up automated reports and alerts for firewall changes and suspicious events.

**Example (Log aggregation):**
```bash
# Forward logs to central syslog server
*.* @syslog-server.example.com:514
```
**Example (CloudWatch for AWS):**
- Create alarms for security group changes or denied connections.

_Verifying:_
- Check dashboards, email alerts, and incident tickets.


> Alert on rule changes, new open ports, and denied connection spikes.


---


**10.4 Recommended Learning and Reference Resources**

- [AWS Security Groups Documentation](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html)
- [Azure Network Security Groups](https://docs.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview)
- [GCP Firewall Rules](https://cloud.google.com/vpc/docs/firewalls)
- [iptables Tutorial](https://wiki.nftables.org/wiki-nftables/index.php/Iptables-translate)
- [firewalld Documentation](https://firewalld.org/documentation/)
- [UFW Manual](https://help.ubuntu.com/community/UFW)
- [SELinux Project](https://selinuxproject.org/page/Main_Page)
- [AppArmor Documentation](https://gitlab.com/apparmor/apparmor/wikis/home)
- [Chef InSpec](https://www.chef.io/products/chef-inspec)


---
