# 7. Scheduling Tasks and Viewing Logs

This section covers task automation, job scheduling, and log management for DevOps engineers on Linux systems.

---

## 7.1 Scheduling Tasks with Cron and At

**A. Cron for Recurring Jobs**

Cron runs commands on a schedule with minute-level precision. Each user can have their own crontab, and there are also system-wide cron files.

Basic Guides:
- Edit your crontab: `crontab -e`
- List current crontab: `crontab -l`
- Remove current crontab: `crontab -r` (careful)
- Run as another user (root only): `sudo crontab -u username -e`
- Service names:
  - Debian/Ubuntu: `cron` (check: `systemctl status cron`)
  - RHEL/CentOS/Fedora: `crond` (check: `systemctl status crond`)
  

**Cron Expression Format**

Standard 5-field format: `minute` `hour` `day-of-month` `month` `day-of-week`

                           *     *      *             *         *            <Commands/Scripts>

```
| Field         | Range        | Notes                         |
|---------------|--------------|-------------------------------|
| Minute        | 0–59         |                              |
| Hour          | 0–23         |                              |
| Day of Month  | 1–31         |                              |
| Month         | 1–12         |                              |
| Day of Week   | 0–6 (Sun–Sat)| 0=Sunday                     |
```

Operators:
- Ranges: `1-5`
- Lists: `1,2,5`
- Steps: `*/5` (every 5 units), `1-10/2`
- Aliases: `@reboot`, `@hourly`, `@daily`, `@weekly`, `@monthly`, `@yearly`

> Important matching rule: a job runs when EITHER day-of-month OR day-of-week matches (not necessarily both).

**Examples:**
```
# Every day at 03:00
0 3 * * * /usr/local/bin/backup.sh >> /var/log/backup.log 2>&1

# Every 5 minutes
*/5 * * * * /usr/local/bin/ping-health

# Weekdays at 09:15
15 9 * * 1-5 /usr/local/bin/report.sh

# First of every month at 02:30
30 2 1 * * /usr/local/bin/monthly.sh

# At reboot (cron daemon start)
@reboot /usr/local/bin/startup-check

@daily /path/to/script.sh
```

**Examples:**
- **Daily at 3AM:**  
  `0 3 * * * /path/to/script.sh`
- **Every 15 minutes:**  
  `*/15 * * * * <command>`
- **Weekdays at 5PM:**  
  `0 17 * * 1-5 <command>`
- **Show logged-in users at 9AM:**  
  `0 9 * * * who >> loginlist`
- **Each minute:**  
  `* * * * * who >> ~/loginlist`
- **Each 15 min:**  
  `*/15 * * * * who >> ~/presentlist`
- **Check users, memory, and date every 2 min:**  
  `*/2 * * * * (who;date)>>listwithdate`
- **Memory and disk info every 2 min:**  
  `*/2 * * * * (echo "= $(date) ="; free -h; df -h) >> info`

**Verification:**
```bash
crontab -l   # List current user's jobs
sudo crontab -l -u username  # List jobs for another user
```


****Where Cron Reads Jobs From? System-wide CronJobs:**
- Per-user crontabs: `/var/spool/cron/crontabs/<user>` (edit via `crontab -e`)
- System crontab: `/etc/crontab` (has an extra “user” field)
- Drop-in directory: `/etc/cron.d/*` (also has “user” field)
- Periodic directories (run by `run-parts`):
  - `/etc/cron.hourly/`
  - `/etc/cron.daily/`
  - `/etc/cron.weekly/`
  - `/etc/cron.monthly/`

Note: `run-parts` imposes strict filename rules (no dots by default on many distros). Use hyphens/underscores instead.

**Format differences**
- User crontab (5 fields): `m h dom mon dow command`
- `/etc/crontab` and `/etc/cron.d/*` (6 fields): `m h dom mon dow user command`

Example in `/etc/cron.d/`:
```
# m  h  dom mon dow  user  command
15  1  *   *   *     root  /usr/local/bin/rotate-keys
```

**Environment in Cron**

Cron runs with a minimal environment. Set what you need explicitly.

Common headers (at top of crontab):
```
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
MAILTO=ops@example.com      # or empty to suppress mail: MAILTO=""
# TZ settings vary by implementation; see below
```

- PATH: Always set full PATH or use absolute paths for commands.
- MAILTO: Cron emails stdout/stderr to this address if a local MTA is configured.
- SHELL: Use bash if your scripts rely on bash-isms.


**Timezones and DST**
- Cron typically uses the system timezone.
- Vixie/modern cron often support per-line `CRON_TZ=Zone/Name` and global `TZ=...` (but not universal across all implementations).
- DST: Jobs may skip or run twice during transitions. For critical jobs, make them idempotent or use systemd timers with `OnCalendar=` and `Persistent=`.

**Examples:**
```
# Whole file in UTC (if implementation supports)
TZ=UTC
0 6 * * * /usr/local/bin/daily-report

# Per-job timezone (Vixie cron / Debian/Ubuntu often support)
CRON_TZ=US/Eastern
0 6 * * * /usr/local/bin/east-coast-task
```

**Output, Logging, and Debugging**

- Redirect output to logs:
  - `>> /var/log/task.log 2>&1` (append)
  - `> /var/log/task.log 2>&1` (overwrite)
- Syslog locations:
  - Debian/Ubuntu: `/var/log/syslog` (grep cron)
  - RHEL/CentOS: `/var/log/cron`
  - Journal: `journalctl -u cron` or `journalctl -u crond`
- Test command interactively first, then paste into crontab.
- Use absolute paths for binaries and files.
- Remember percent signs `%` are special in Vixie cron: they are converted to newlines in the command. Escape as `\%` or quote the command.


**Avoid Overlaps and Long Runs**

To prevent parallel runs:
```
# flock-based locking (preferred)
*/5 * * * * flock -n /var/lock/myjob.lock -c "/usr/local/bin/myjob >> /var/log/myjob.log 2>&1"

# or with a subshell:
*/5 * * * * /usr/bin/flock -n /var/lock/myjob.lock /usr/local/bin/myjob >> /var/log/myjob.log 2>&1
```

Stagger schedules with sleep:
```
# Stagger start by up to 30s
*/5 * * * * sleep $((RANDOM % 30)); /usr/local/bin/worker
```

Throttle impact:
```
# Lower CPU and IO priority
0 * * * * nice -n 10 ionice -c2 -n7 /usr/local/bin/big-job
```
---

**B. Managing Crontab and One-Time Jobs**

| Action                | Command                       | Notes                              |
|-----------------------|------------------------------|------------------------------------|
| Edit jobs             | `crontab -e`                 | Current user                       |
| List jobs             | `crontab -l`                 |                                    |
| Remove all jobs       | `crontab -r`                 | CAREFUL: removes all jobs          |
| Edit root's jobs      | `sudo crontab -e`            | For system or root jobs            |
| Set environment vars  | At top of crontab            | e.g., `PATH=/usr/local/sbin:/usr/sbin:/sbin:/usr/bin:/bin` |
| Restart cron service  | `sudo systemctl restart crond`| After major changes or troubleshooting |
| Logging/Output        | `> /path/to/log 2>&1`        | Or discard: `> /dev/null 2>&1`     |


**One-Time Jobs with `at`:**
```bash
at now + 1 hour
at> echo "Hello from at!" >> /tmp/atlog
at> <Ctrl-D>
atq      # List scheduled at jobs
atrm <job_id>   # Remove at job
```


---

## 7.2 Viewing and Managing Logs

**A. Understanding Log Locations**

- **Primary Directory:** `/var/log/`
- **Common Log Files:**
  - `syslog` or `messages`: General system activity
  - `auth.log` or `secure`: Authentication events
  - `kern.log`: Kernel messages
  - `boot.log`: Boot process logs
  - Application logs: `/var/log/nginx/`, `/var/log/apache2/`, etc.

**Log Format:**
```
<timestamp> <hostname> <service>[pid]: <message>
```

**Systemd Journals:**  
- Stored in `/var/log/journal` if persistent enabled

---

### B. **Viewing Logs**

| Tool      | Example Command                               | Use Case                |
|-----------|-----------------------------------------------|-------------------------|
| `ls`      | `ls /var/log`                                 | List log files          |
| `cat`     | `sudo cat /var/log/messages`                  | View entire file        |
| `tail`    | `sudo tail -n 20 /var/log/secure`             | Last 20 lines           |
| `tail -f` | `sudo tail -f /var/log/messages`              | Real-time monitoring    |
| `less`    | `less /var/log/dnf.log`                       | Interactive scroll/search|
| `grep`    | `grep "failed" /var/log/secure`               | Filter lines            |
| `zgrep`   | `zgrep "failed" /var/log/auth.log.1.gz`       | Search compressed log   |

**Systemd/Journalctl:**
```bash
journalctl -u nginx.service         # Logs for nginx service
journalctl -b                      # Logs since last boot
journalctl -p err -b               # Errors since boot
journalctl -f                      # Follow new logs
journalctl --since "2024-10-01" --until "2025-04-02"
```
Export logs:
```bash
journalctl -u sshd > sshd_logs.txt
```

**Best Practice:**  
For large logs, prefer `tail`, `less`, or `grep` over `cat`. Use `sudo` for restricted logs.

---

### C. **Rotating Logs with logrotate**

**Purpose:**  
Prevents logs from consuming disk space by compressing/archiving old logs.

**Main Config:**
```bash
cat /etc/logrotate.conf
```
**Service-Specific Configs:**  
- Located in `/etc/logrotate.d/`

**Example Nginx Config:**
```
/var/log/nginx/*.log {
    daily
    missingok
    rotate 7
    compress
    delaycompress
    notifempty
    create 0640 www-data adm
    sharedscripts
    postrotate
        systemctl reload nginx
    endscript
}
```

**Manual Rotation:**
```bash
logrotate -vf /etc/logrotate.d/nginx     # Force rotation
logrotate -d /etc/logrotate.d/nginx      # Dry-run/debug
```

**Track Last Rotation:**
```bash
cat /var/lib/logrotate/status
```

**Best Practice:**  
Review logrotate configs monthly. Verify application logs are rotated and compressed. Use `journalctl` for systemd-based logs.

---

## 7.3 Cloud/Scheduled Jobs & Log Management Context

### **AWS Example (Scheduled Tasks)**
- Use **CloudWatch Events** or **EventBridge** for scheduled Lambda/EC2 actions.
- Use **CloudWatch Logs** for log aggregation and retention policies.

### **Azure Example**
- Use **Azure Automation Runbooks** or **Logic Apps** for scheduled tasks.
- Use **Azure Monitor Logs** for log collection and analysis.

### **GCP Example**
- Use **Cloud Scheduler** for cron-like scheduled jobs.
- Use **Cloud Logging** for system and application log management.

_Best Practice:_  
Always configure log retention and alerting in cloud environments. Ensure scheduled jobs and log rotation are centrally monitored.

---

## 7.4 Security & Best Practices

| Area        | Recommendation |
|-------------|---------------|
| Cron jobs   | Use least privilege; do not run as root unless required. |
| Scripts     | Validate scripts before scheduling. Redirect output to logs. |
| Environment | Set `PATH` and other vars explicitly in crontab. |
| Logging     | Monitor logs for errors, failed jobs, and security issues. |
| Rotation    | Ensure all logs are rotated and retained per compliance. |
| Cloud       | Use native scheduling/logging tools for automation and auditing. |
| Alerting    | Combine log monitoring with alerting for failures/security events. |

---

## 7.5 Cheat Sheet

```bash
# Edit crontab for current user
crontab -e

# List jobs
crontab -l

# Remove all jobs
crontab -r

# Edit root's crontab
sudo crontab -e

# Schedule one-time job with at
at now + 10 minutes

# View logs
sudo tail -n 50 /var/log/syslog

# Follow log
sudo tail -f /var/log/messages

# Search for failed logins
grep "failed" /var/log/auth.log

# View journalctl errors since boot
journalctl -p err -b

# Logrotate manual run
logrotate -vf /etc/logrotate.d/nginx

# Cloud: AWS scheduled Lambda
aws events put-rule --schedule-expression "rate(1 hour)" --name MyRule

# Azure: List log analytics workspaces
az monitor log-analytics workspace list

# GCP: List scheduled jobs
gcloud scheduler jobs list
```

---

## 7.6 Example Scenario: Real-World Job & Log Verification

1. **Schedule a script to run daily at 2AM:**
   ```bash
   echo "0 2 * * * /home/user/backup.sh >> /home/user/backup.log 2>&1" | crontab -
   ```
2. **Verify job is scheduled:**
   ```bash
   crontab -l
   ```
3. **Check log output:**
   ```bash
   tail -n 20 /home/user/backup.log
   ```
4. **Rotate logs manually if space is low:**
   ```bash
   sudo logrotate -vf /etc/logrotate.d/backup
   ```
5. **Monitor for errors:**
   ```bash
   grep "error" /home/user/backup.log
   journalctl -p err -b
   ```

---

## 7.7 Advanced/Enterprise Enhancements

### A. **systemd Timers**

**systemd timers** offer modern, robust scheduling and are preferred on new Linux systems:

- **Create timer unit:**  
  `/etc/systemd/system/myjob.timer`
  ```
  [Unit]
  Description=Run myjob every day

  [Timer]
  OnCalendar=daily
  Persistent=true

  [Install]
  WantedBy=timers.target
  ```
- **Create service unit:**  
  `/etc/systemd/system/myjob.service`
  ```
  [Unit]
  Description=Run myjob script

  [Service]
  Type=simple
  ExecStart=/path/to/script.sh
  ```
- **Enable & start timer:**  
  ```bash
  systemctl enable --now myjob.timer
  systemctl list-timers
  ```

**Best Practice:**  
Use systemd timers for complex or dependency-aware scheduling, logging is integrated via journalctl.

---

### B. **Centralized Log Aggregation**

Aggregate logs for analytics, search, and alerting:

- **ELK Stack (Elasticsearch, Logstash, Kibana):**
  - Ship logs using Filebeat or Logstash.
  - Visualize/search in Kibana.

- **Datadog/CloudWatch/Splunk:**
  - Use agent or cloud-native integrations for log shipping.
  - Set up dashboards and alerting rules.

**Best Practice:**  
Forward logs from all hosts to a central platform. Use tags/labels for environment/app identification.

---

### C. **Alerting Integrations**

Automate notifications and incident response:

- **Email/Webhooks:**  
  Use log monitoring tools (ELK, Datadog, custom scripts) to send alerts.
- **PagerDuty/Slack Integration:**  
  Connect alert systems for immediate notification.

**Example (ELK Watcher):**
```json
{
  "trigger": {
    "schedule": { "interval": "1m" }
  },
  "input": {
    "search": { "request": { /* search for errors */ } }
  },
  "actions": {
    "email_admin": {
      "email": { "to": "admin@example.com", "subject": "Log Error Found", ... }
    }
  }
}
```

**Best Practice:**  
Always test alerting flows; simulate failures regularly.

---

### D. **Advanced Audit and Compliance Reporting**

- Use tools like **auditd** for OS-level tracking.
- Export and rotate audit logs.
- Integrate with SIEM (Security Information and Event Management) for compliance.

**auditd Example:**
```bash
auditctl -w /etc/passwd -p wa -k passwd_changes
ausearch -k passwd_changes
```

**Best Practice:**  
Regularly review audit logs and automate compliance reporting.

---

### E. **Container-Native Scheduling and Logging**

- **Kubernetes CronJob:**
  ```yaml
  apiVersion: batch/v1
  kind: CronJob
  metadata:
    name: my-cronjob
  spec:
    schedule: "0 2 * * *"
    jobTemplate:
      spec:
        template:
          spec:
            containers:
            - name: job
              image: busybox
              args: ["echo", "hello world"]
            restartPolicy: OnFailure
  ```
- **Sidecar Logging:**
  - Deploy log collector containers (e.g., Fluentd) alongside app containers for centralized logging.

**Best Practice:**  
Implement CronJobs for scheduled workloads; aggregate logs with Fluentd/Filebeat to central log management.

---

### F. **Automated Recovery/Remediation Jobs**

- Use automated scripts or orchestration tools to respond to detected failures (e.g., restart service, scale resources).
- Integrate with alerting systems to trigger remediation flows.

**Example:**
- AWS Lambda triggered by CloudWatch alert to remediate unhealthy EC2.
- Ansible playbook scheduled to run on incident detection.

---

## 7.8 References (Suggested Further Study)

- `man crontab`, `man at`, `man logrotate`, `man systemd.timer`, `man auditd`
- [systemd timers](https://www.freedesktop.org/software/systemd/man/systemd.timer.html)
- [ELK Stack](https://www.elastic.co/what-is/elk-stack)
- [Datadog Log Management](https://docs.datadoghq.com/logs/)
- [Splunk Logging](https://docs.splunk.com/)
- [AWS Events & Logs](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/)
- [Azure Automation](https://learn.microsoft.com/en-us/azure/automation/)
- [GCP Cloud Scheduler](https://cloud.google.com/scheduler/docs)
- [Kubernetes CronJobs](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)
- [Linux Logging & Monitoring](https://wiki.archlinux.org/title/log_files)

---

_Best Practice:_  
Automate recurring and one-time jobs with cron/at, systemd timers, K8s CronJobs, and cloud-native schedulers. Monitor and rotate logs for system health, compliance, and forensics. Integrate centralized logging, alerting, and automated remediation for enterprise reliability. Always verify and document job and log setups.

---
