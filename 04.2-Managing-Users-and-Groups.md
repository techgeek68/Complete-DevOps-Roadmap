# 3. Managing Users and Groups

---

Managing users and groups is a big part of a DevOps engineer’s job. It’s all about keeping systems secure, organized, and making sure access is handled automatically. As a DevOps engineer, you want to make sure the right people have the right access—no more, no less. It keeps your systems safe, organized, and easier to maintain, especially when things change or teams grow.

---

**What is a Group?**

A **group** is a collection of user accounts. Groups help you manage permissions for multiple users at once—making it easier to control access to files, folders, or tools.

**Types of Groups**

- **Primary Group:**  
  Each user is assigned to a primary group when their account is created. Files created by the user are usually associated with this group.
- **Secondary (or Supplementary) Groups:**  
  Users can also belong to additional groups, giving them access to more resources or permissions.
- **System Groups:**  
  Like system accounts, these are used by the system or software for specific tasks (for example, `sudo`, `docker`, `adm`).


---

## **1. Creating, Modifying, and Deleting Groups**

**Primary Group**
- Every user belongs to one main group—called the primary group. When you create a user, you can set this with useradd -g, but if you don’t, the system does it for you.
- You’ll see the primary group’s ID (GID) in the /etc/passwd file. For example:
  ```
  alice:x:1001:100:Alice:/home/alice:/bin/bash
  ```
  >100 is the GID of the primary group for alice.

**Secondary Group**
- Users can also be part of extra groups—these are called secondary groups. You add them with useradd -G or later using usermod -aG.
- All group memberships are listed in /etc/group. If you want to edit group memberships directly, you can open the file:
- You can also edit group membership directly:
  ```
  vim /etc/group
  ```

**Create a Group**

```
groupadd developer
```
```
groupadd operation
```
```
groupadd support
```
```
groupadd -g 1009 admin                  # Creates group 'admin' with a specific GID
```

**View Groups Information**

```
cat /etc/group
```

*Format: `<groupname>:x:<GID>:<members>`*


**Modify a Group**

```
groupadd admin
```
```
groupmod -n administration admin
```
*(Renames 'admin' to 'administration')*


**Delete a Group**

```
groupdel admin
```

---

## **2. Creating, Modifying, and Deleting Users**

**What is a User?**

A **user** is basically an account that represents an individual (or sometimes a service) on a system. Users have their own credentials (like username and password), files, and permissions.

**Types of Users**

- **Normal/User Accounts:**  
  These are regular accounts for people who use the system, such as developers, admins, or team members.
- **System Accounts:**  
  Used by the operating system or installed software/services. These accounts run background processes and usually don’t log in like humans do (for example, `root`, `daemon`, `www-data`).
- **Root/Superuser:**  
  The "root" account has unlimited access to everything on the system. Used for administration and maintenance tasks.

  Syntax: `sudo adduser username`

**Create a User**

```
useradd harry
```
```
cat /etc/passwd | grep harry
```
*Format: `<username>:x:<UID>:<GID>:<Comment>:<home_directory>:<shell>`*

**Check User Groups**

```
groups harry
```

**Create User with Primary and Secondary Groups**

```
useradd -g developer -G operation david
```
```
groups david
```
*developer = primary group, operation = secondary group*

<img width="584" height="90" alt="Screenshot 2025-10-16 at 11 27 37 AM" src="https://github.com/user-attachments/assets/abe0715a-a4d9-4449-96cc-16a00e0bb642" />


**Create User with Home Directory, Shell, and Secondary Group**

This command creates a new user named Thomas, makes a home directory for him, sets his default shell to /bin/bash, and adds him to the wheel group (so he can use sudo):
```
useradd -m -s /bin/bash -G wheel thomas
```
```
passwd thomas
```
```
su – thomas
```
```
sudo useradd natasha
```

---

**Set or Change User Password**

Changing another user's password
```
sudo passwd natasha
```
```
su – natasha
```
```
whoami
```
```
exit
```
```
sudo passwd -l natasha
```
*(Lock natasha’s account)*
```
su – natasha
```
*(Should be denied)*
```
passwd -u natasha
```
*(Unlock natasha’s account)*
```
su – natasha
```
```
exit
```

<img width="822" height="804" alt="Screenshot 2025-10-16 at 11 35 25 AM" src="https://github.com/user-attachments/assets/a7136e20-8e93-41a1-bdb8-07dd04e4d247" />

---

**Modify an Existing User**

```
cat /etc/group | grep thomas
```
```
usermod -a -G operation thomas
```
```
cat /etc/group | grep thomas
```
```
usermod -g phpdev -G staff,support thomas
```
```
groups thomas
```

---

**Delete a User**

```
userdel -r david
```
*(Removes home and mail spool)*

```
cat /etc/passwd | grep david
```
```
cd /
```
```
cd home
```
```
ls
```
```
cd
```

<img width="599" height="175" alt="Screenshot 2025-10-16 at 11 47 34 AM" src="https://github.com/user-attachments/assets/c26a872e-1a67-4d00-9444-3ee8d20e5ef6" />

---

## **3. Managing Sudo Permissions**

**Edit Sudoers File Safely**

```
sudo visudo
```

**Allow a Specific User Passwordless Sudo**
Add the following line to allow the user Natasha to run any command via sudo without a password prompt:
```
natasha ALL=(ALL) NOPASSWD: ALL
```
*(Allow user 'natasha' passwordless sudo)*


**Allow a Group Full Sudo (with Password)**
      
Search: `/%wheel`

*Key directives:*
```
%wheel ALL=(ALL) ALL
```
*(Allow group "wheel" full sudo)*

---

## **4. Managing Permissions and Ownership**

**Changing Ownership: chown**

```
touch htmlfile
```
```
mkdir htmldir
```

Shows new ownership for a file
```
ls -l htmlfile
```

Shows new ownership for a directory
```
ls -ld htmldir
```

Changes owner to Natasha and group to developer for htmlfile.
```
sudo chown natasha:developer htmlfile
```

Changes the owner of htmldir and all contents (if any) to harry.(recursively)
```
chown -R harry htmldir
```

```
ls -l htmlfile
```
```
ls -ld htmldir
```

<img width="590" height="389" alt="Screenshot 2025-10-16 at 12 00 13 PM" src="https://github.com/user-attachments/assets/9b6c06a7-8644-4359-b0f2-4d93700631ff" />

---

**Changing Permissions: chmod**

**Ownership Classes**
- User (u): Owner
- Group (g): Group
- Others (o): Everyone else

**Permission Types**
| Type    | Symbol | Numeric |
|---------|--------|---------|
| Read    | r      | 4       |
| Write   | w      | 2       |
| Execute | x      | 1       |
| Full    | rwx    | 7       |
| None    | -      | 0       |

**Examples**

```
touch permissionfile
```
```
mkdir permissiondir
```

```
ls -l permissionfile
```
```
ls -ld permissiondir
```

**Symbolic Notation**

Syntax:
```
chmod u+rwx file_name
```
```
chmod g-w file_name
```
```
chmod a=rw file_name
```

**Examples:**

Change directory permissions:
- Owner: read & execute
- Group: no permissions
- Others: no permissions
```
chmod u=rx,g=,o= permissiondir
```
Verify:
```
ls -ld permissiondir
```

Enter the directory & create a file:
```
cd permissiondir
```
```
touch file
```
If you’re the owner, you can enter (x) and create (w) only if the owner has write permission.

```
cd
```

Change directory permissions:
  - Owner: rwx
  - Group: r-x
  - Others: no permissions
```
chmod u=rwx,g=rx,o= permissiondir
```
```
ls -ld permissiondir
```
```
cd permissiondir
```
```
touch file
```
```
ls
```
```
cd
```

Change directory permissions:
  - Owner: r-x
  - Group: no permissions
  - Others: unchanged
```
chmod u=rx,g= permissionfile
```
```
ls -l permissionfile
```
```
vim permfile
```
*Try editing the file to test permissions. If the owner has no write permission, editing will fail (read-only).*


**Octal Notation**
- Each digit represents: User (Owner), Group, Others
- Permission values:
  r (read) = 4
  w (write) = 2
  x (execute) = 1
- Add values for each (e.g., rwx = 4+2+1 = 7)

Example:
Change permission:
  - Owner: read + execute (r-x)
  - Group: no permissions (---)
  - Others: no permissions (---)
```
chmod 500 permissiondir
```
```
ls -ld permissiondir
```
```
cd permissiondir
```
```
touch newfile
```
Will fail unless the owner also has write (w) permission. With only r-x, the owner cannot create files.
```
cd
```

Change the permission:
  - Owner: read + write + execute (rwx)
  - Group: read + execute (r-x)
  - Others: no permissions (---)
```
chmod 750 permissiondir
```
```
ls -ld permissiondir
```
```
cd permissiondir
```
```
touch file
```

---

**Changing Group Ownership: chgrp**

Create a file and a directory:
```
touch file
mkdir shared_dir
```

View initial ownership:
```
ls -l file
ls -ld shared_dir
```

Change the group of the file to admins
```
chgrp admins file
```

Change the group of the directory to the team:
```
chgrp team shared_dir/
```
Verify changes:
```
ls -l file
ls -ld shared_dir
```

<img width="886" height="320" alt="Screenshot 2025-10-16 at 1 08 07 PM" src="https://github.com/user-attachments/assets/a8a32c38-6473-45ea-a667-d2b7bc3e7058" />

---

## **5. umask, Sticky Bit, and Special Permissions**

**umask**
umask (short for "user file creation mask") is a Linux/Unix shell command and system setting that determines the default permissions (read, write, execute) assigned to newly created files and directories.

**How umask works:**
- When you create a file or directory, the system starts with a set of default permissions (usually 666 for files and 777 for directories).
- The umask value is subtracted from these defaults to determine the final permissions.

**Example:**
- Default permission for files: **666** (rw-rw-rw-)
- If your umask is **022**, subtract it:
  - File: **666 - 022 = 644** (rw-r--r--)
- Default permission for directories: **777**
  - Directory: **777 - 022 = 755** (rwxr-xr-x)

- Show current umask:
```
umask     
```
*Set Temporary:*
Example:
```
umask 022
```
- This means new directories get permissions: 755 (rwxr-xr-x)
- New files get permissions: 644 (rw-r--r--)
(Because by default, files never get execute permission.)

Verify:
```
mkdir testdir
touch testfile
```
```
ls -ld testdir    # Permissions should be: drwxr-xr-x (755)
ls -l testfile    # Permissions should be: -rw-r--r-- (644)
```
- umask 022 removes write permission for group/others.
- Directories get 755 (rwxr-xr-x)
- Files get 644 (rw-r--r--)

<img width="653" height="250" alt="Screenshot 2025-10-16 at 5 08 04 PM" src="https://github.com/user-attachments/assets/a23c0816-2555-4e8d-8efe-b917da6d0934" />


*Set permanently:*
For current user:
```
vim ~/.bashrc
```
Add this line at the end:
```
umask 222
```
Save and exit, then reload:
```
source ~/.bashrc
```

<img width="651" height="441" alt="Screenshot 2025-10-16 at 5 10 45 PM" src="https://github.com/user-attachments/assets/69ca601c-359d-44df-b54b-137a6764cb4d" />

```
umask
```

Test and Verify:
```
mkdir testdir1
touch testfile1
```
```
ls -ld testdir
ls -l testfile
```

<img width="579" height="182" alt="Screenshot 2025-10-16 at 5 14 06 PM" src="https://github.com/user-attachments/assets/6f4b0744-56f3-4efc-bb45-0e01542abe35" />


For all users (system-wide):
```
vim /etc/profile
```
Add:
```
umask 022
```
Save and exit, then reload:
```
source /etc/profile
```

---

**Sticky Bit**
Sticky Bit is a special permission that can be set on directories in Unix/Linux systems. It is used on shared directories to prevent users from deleting/renaming files they don't own, even if they have write permission.

Example:
Create a test directory:
```
mkdir stickytest
```

Set the sticky bit using symbolic notation:
The sticky bit (+t) means only the file’s owner (or root) can delete or rename files in this directory, even if others have write permission.
  Syntax: `chmod +t directory_name`
```
chmod +t stickytest
```

or
Set the sticky bit using octal notation:
```
chmod 1777 directory_name
```
- 1 = sticky bit; 777 = full permissions for owner, group, others.
- This is common for shared directories like /tmp.

Verify:
```
ls -ld  /tmp
```
```
ls -ld stickytest
```

<img width="886" height="320" alt="Screenshot 2025-10-16 at 1 08 07 PM" src="https://github.com/user-attachments/assets/266c6f68-b424-4611-89a4-b493940a95d8" />

---

**Special Permissions**:

Special permissions in Unix-like systems allow for advanced file and directory access control. The two commonly used special permissions are setuid and setgid. These can be set using the chmod command.

**Setuid**:
Setuid (Set User ID) allows a user to execute a file with the permissions of the file owner, rather than the permissions of the user who runs the file. This is commonly used for executables that need elevated privileges.

  Syntax `chmod u+s file_name` or `chmod 4755 file_name`
  
Example:
```
touch myprog
```
```
ls -l myprog
```
output: -rwxr-xr-x 1 root root 12345 Oct 16 11:31 myprog

```
chmod u+s myprog
```

```
ls -l myprog
```
Output: -rwsr-xr-x 1 root root 12345 Oct 16 11:31 myprog

<img width="579" height="124" alt="Screenshot 2025-10-16 at 6 04 00 PM" src="https://github.com/user-attachments/assets/cd42ca17-c2d0-49a8-90ee-56c53cf97070" />


**Setgid**:
Setgid (Set Group ID) on files causes the executable to run with the permissions of the file's group owner. On directories, it ensures that files created within inherit the group of the directory, rather than the user's default group.

  Syntax: `chmod g+s directory` or `chmod 2770 directory`
  
Example:
```
mkdir shared
```
```
ls -ld shared
```
Output: drwxrwxr-x 2 alice staff 4096 Oct 16 11:31 shared

```
chmod g+s shared
```
```
ls -ld shared
```
Output: drwxrwsr-x 2 alice staff 4096 Oct 16 11:31 shared

<img width="650" height="141" alt="Screenshot 2025-10-16 at 6 07 20 PM" src="https://github.com/user-attachments/assets/80030601-0bbd-4039-8b5e-26b8679460b9" />

---

## **6. Access Control Lists (ACLs)**

Access Control Lists (ACLs) provide fine-grained permissions for files and directories, allowing you to specify access for multiple users and groups, beyond the standard user/group/other model.

**View ACLs**

  Syntax: `getfacl <file_name>`

**Options**
| Option | Meaning                                   | Example                                |
|--------|-------------------------------------------|----------------------------------------|
| `-m`   | Modify/Add an ACL entry                   | `setfacl -m u:david:rwx file`          |
| `-x`   | Remove an ACL entry                       | `setfacl -x g:developer file`          |
| `-b`   | Remove all ACLs (except basic permissions)| `setfacl -b file`                      |
| `-d`   | Set default ACLs on directories           | `setfacl -d -m g:dev:r-- dir/`         |
| `-R`   | Apply changes recursively                 | `setfacl -R -m g:dev:r-- dir/`         |

Example:
```
touch ACLs_file
```
```
getfacl ACLs_file
```

<img width="616" height="177" alt="Screenshot 2025-10-16 at 6 12 42 PM" src="https://github.com/user-attachments/assets/6f55d56b-176a-4b1f-8c59-dba0cbd7e7e8" />


**Modify ACLs**

To grant user `natasha` full access (rwx) to a file:
```
setfacl -m u:natasha:rwx file
```

To grant group `developer` read-only access:
```
setfacl -m g:developer:r-- file
```

To remove all ACL entries for user `natasha`:
```
setfacl -x u:natasha file
```

<img width="778" height="588" alt="Screenshot 2025-10-16 at 6 18 05 PM" src="https://github.com/user-attachments/assets/1926d27e-a18b-43f5-b887-cd1311ae57c0" />


**Default ACLs for Directories**
Default ACLs ensure that new files/directories created inside inherit the specified ACL. For example, to give user `harry` rwx access by default in directory `dir/`:

```
mkdir dir
```
```
setfacl -d -m u:harry:rwx dir/
```

<img width="564" height="262" alt="Screenshot 2025-10-16 at 6 21 33 PM" src="https://github.com/user-attachments/assets/cca38c4a-d08d-4558-a0f0-d127aa980940" />

*Note: The Filesystem must be mounted with ACL support.*

---

## **7. User Authentication & DevOps Workflows**

Modern infrastructure uses centralized authentication and automation to streamline user management and enforce security policies. Below are key components and practical examples.

---

### **Centralized Authentication**
Systems often rely on centralized identity sources to manage users and permissions across servers and services:
- **LDAP / OpenLDAP:** Directory service protocol for centralized user/group management.
- **Active Directory (winbind, SSSD):** Microsoft’s directory solution, often integrated with Linux via winbind or SSSD.
- **Kerberos:** Network authentication protocol for secure, single sign-on.

---

### **Pluggable Authentication Modules (PAM)**
PAM enables flexible authentication, password, and session configuration through stackable modules.
- Config files: `/etc/pam.d/common-auth`, `common-password`, `common-session`
- Typical tasks: Enforce password policies, enable 2FA, integrate LDAP authentication.

*Example: Enabling 2FA with PAM (Google Authenticator):*
```bash
# In /etc/pam.d/sshd, add:
auth required pam_google_authenticator.so
```

---

### **Automation Tools**
Configuration management and infrastructure-as-code tools automate user and group management, ensuring consistency and compliance.

*Example: Ansible user module for idempotent user creation:*
```yaml
- name: Ensure user exists
  ansible.builtin.user:
    name: devuser
    groups: developers
    password: "{{ vault_user_password }}"
    state: present
```

*Example: Terraform AWS IAM user creation:*
```hcl
resource "aws_iam_user" "devuser" {
  name = "devuser"
}
```

---

### **Secrets Management**
Safely store and retrieve sensitive data like passwords, API keys, and certificates.
- **HashiCorp Vault**
- **AWS Secrets Manager**
- **Azure Key Vault**

*Example: Fetch secret in Ansible from Vault:*
```yaml
- name: Retrieve secret from HashiCorp Vault
  ansible.builtin.set_fact:
    db_password: "{{ lookup('hashi_vault', 'secret/data/db#password') }}"
```

---

### **Container & CI Integration**
Automate and secure access in containerized and CI/CD environments.
- **Dockerfile:** Specify users for running containers.
- **Kubernetes RBAC:** Define roles and role bindings for access control.
- **CI Pipelines:** Service accounts manage build/test/deploy permissions.

*Example: Dockerfile setting user:*
```Dockerfile
FROM ubuntu:22.04
RUN useradd -m appuser
USER appuser
```

*Example: Kubernetes RoleBinding for CI service account:*
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ci-pipeline-binding
roleRef:
  kind: Role
  name: deploy-role
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: ci-service-account
  namespace: ci
```

---
### **Additional Knowledge**

**Best Practices**
- Use the root account only for system setup and troubleshooting in test environments.
- In production, prefer using `sudo` for elevated operations to minimize risks.


**Automation**
- Employ configuration management tools such as **Ansible**, **Puppet**, and **Chef** for repeatable, auditable user, group, and permission management.
- Infrastructure-as-Code ensures consistency and enables version control for configuration changes.


**Security**
- Regularly audit critical files: `/etc/passwd`, `/etc/group`, and `/etc/sudoers` to check for unauthorized changes.
- Lock unused accounts to prevent potential abuse:
  ```bash
  usermod -L olduser
  ```
- Enforce strong password policies using PAM modules and automation tools.


**More Examples**

**Container Workflows**
Define users in Dockerfiles for least-privilege execution:
```Dockerfile
USER appuser
```

**Kubernetes Service Accounts**
Create and manage service accounts for CI/CD or automation tasks:
```bash
kubectl create serviceaccount buildbot
```
---

-
]]]]]]]]]]]]]]]--
