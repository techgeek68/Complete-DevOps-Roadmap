**Developers vs Operations:**

```
Category                Developers                                    Operations (Ops/DevOps/SRE)


Primary Role:           -Write, test, and maintain software            -Manage infrastructure, deploy, and ensure system uptime


Key Responsibilities:   -Writing code                                  -Managing servers
                        -Building features                             -Handling deployments
                        -Fixing bugs                                   -Monitoring systems           
                        -Working on apps, websites, and services       -Ensuring security, backups, and scaling

 
Examples:               -Python script for automation                   -Local office server admin
                        -Mobile app with Flutter                        -IT team for the hospital system
                        -Web app using React/Django                     -DevOps for retail site
                                                                        -SREs for global cloud uptime


Tools:                  -Git, GitHub, GitLab                           -AWS, Azure, Google Cloud
                        -VS Code, IntelliJ, PyCharm                    -Terraform, Ansible, Puppet
                        -Jenkins, GitHub Actions                       -Prometheus, Grafana, Datadog
                        -Docker, Vagrant                               -Kubernetes, OpenShift


Scale:
                        -From personal scripts to global-scale apps.   -From managing a small server to orchestrating multi-region cloud systems.
                                                              


Focus Area:
                        -Software development and feature delivery.     -Infrastructure stability, performance, and availability.



Collaboration:
                         -Works with Ops to deploy and maintain code.    -Works with Devs to automate, deploy, and monitor systems.
```



**What is DevOps?**

DevOps is a culture and a set of practices that integrate software development (Dev) and IT operations (Ops) to automate and shorten the software development life cycle.

**Core Principles:
Collaboration** :

Developers and Operations teams work together to improve the software delivery lifecycle.
Tools: Slack, Jira, etc

**Automation:**

CI/CD Pipelines automate testing, integration, and deployment processes.
Tools: Jenkins, GitLab CI, CircleCI, etc.

**Monitoring:**

Continuous monitoring of performance and system health to ensure reliability and quick issue resolution.
Tools: Grafana, Prometheus, New Relic, etc


**Who is a DevOps Engineer?**

A **DevOps Engineer** is an IT professional who bridges the gap between development and operations teams to streamline software delivery.
They have a solid understanding of the Software Development Lifecycle (SDLC), and strong technical and communication skills to support automation, CI/CD, infrastructure management, and collaboration across teams.



**Why DevOps?**

- Before DevOps, development and operations teams worked in silos, leading to poor collaboration and inefficiencies.
                                                                            (Task: Write down about: Silo mentality)
  
- Testing and Deployment were isolated activities done after design-build. Hence, they consumed more time than the actual build cycles.
  
- Without using DevOps, teams spent excessive time on manual testing, deployment, and infrastructure setup, reducing focus on the actual development.
  
- Manual deployments increased the risk of human error in production environments
  
- Development and operations are followed separately, with unsynchronized timelines, causing bottlenecks and delays in delivery.

**DevOps Solutions:**

Automated pipelines:
Code changes are automatically tested and deployed without manual steps.

```
Example:
- Developer pushes code to GitHub
- Jenkins runs automated tests
- Docker builds the app into containers
- Kubernetes deploys it live
```

Infrastructure as Code (IaC):
  Servers and resources are created using code instead of being it manually.
  
```
Example:
Use Terraform to set up AWS EC2 servers with just a few lines of code.

```


**When to adopt DevOps:**

- Ideal for large, distributed applications (e.g., e-commerce platforms, cloud-hosted apps).
- Microservices architecture
- Useful for projects needing rapid iteration and automation.
  

**When not to adopt DevOps:**

- Not suitable for mission-critical applications (e.g., banking, power grid, sensitive data systems).
  
- Requires strict access controls, detailed change management, and security measures.
  
- May require a more traditional approach for ensuring data integrity and regulatory compliance.
  
  

**DevOps Life Cycle:**

1. Development:
   
    Software is developed continuously through iterative cycles. The development process is broken into smaller phases, enabling the speed      up software development and delivery process by the DevOps team.
   
3. Testing
   
    During testing, the QA team utilizes tools like Selenium to detect and fix bugs in the new code, ensuring high quality and stability        before integration.
   
5. Integration
   
    New features are integrated with the existing codebase and undergo testing. Continuous development is made possible through ongoing         integration and testing efforts.
   
7. Deployment
   
    In this phase, code is continuously deployed to production. The deployment process is designed to ensure that any changes made to the
    Code does not disrupt the functionality of high-traffic websites or applications.
   
9. Monitoring
    
    The operations team monitors the system for any unexpected behavior or bugs that may arise in the production environment, ensuring          issues are identified and resolved quickly to maintain smooth operation.


**DevOps Stages:**

**Stage 1: Continuous Development**

- Tools used: Git (version control), Github/GitLab (repositories)
  
- Description:
  - Involves planning and coding phases.
  - Project vision and requirements are defined during planning.
  - Developers write code, managed using a Version Control System (VCS) like Git.
  - This practice, known as Source Code Management (SCM), ensures code integrity and facilitates collaboration.
  
```
- Example:
  - A team uses Git to manage their codebase, allowing multiple developers to work concurrently. They employ Git branches to develop features independently, merging them into the main branch after thorough testing.
```

**Stage 2: Continuous Integration (CI)**

- Tools used: Github Actions, GitLab CI, CircleCI, Jenkins
  
- Description:
  - This stage is the core of the entire DevOps life cycle.
  - Developers frequently commit code changes to a shared repository.
  - Each commit triggers automated builds and tests, enabling early detection of issues.
  - Continuous Integration (CI) ensures new code integrates seamlessly with the existing codebase.
  - All the processes can be summarized as “Merge code changes frequently and test automatically.”

```
- Example:
  - In a weather app project, two developers are working on separate features—one for fetching weather data and the other for displaying it.
  - As each developer commits their code, Jenkins automatically tests the changes to ensure they work together.
  - If any issues are found, Jenkins immediately alerts the team, allowing them to fix problems early.
  - This ensures frequent code integration and automatic testing, leading to faster and more reliable development.
```


**Stage 3: Continuous Testing**

- Tools used: Selenium, TestNG, JUnit, Jenkins

- Description:
  - Automated testing is conducted to identify and resolve bugs promptly.
  - Tools like Selenium facilitate functional testing across various browsers.
  - TestNG and JUnit handle unit testing.
  - Integrating these tests into the CI pipeline ensures that only quality code progresses.

```
- Example:
  - Testing an e-learning platform:
      - Selenium:   Automates functional tests (Login → enroll → take exam)
      - JMeter:     Simulate 5k users to check server load.
```


**Stage 4: Continuous Deployment (CD)**

- Tools used:
  
- GitOps tools:
  - Argo CD:     Declarative GitOps CD for Kubernetes
  - Flux CD:     A Lightweight GitOps tool, integrates with Helm/Kustomize

- Cloud Deployment Platforms:
  - Spinnaker:       Multi-cloud CD, supports advanced strategies
  - Harness:         CD-as-a-Service with AI features
  - Octopus Deploy:  Great for hybrid/.NET/Windows environments

- Containerization and Orchestration
  - Docker:            Container packaging and runtime
  - Kubernetes(K8s):   Container orchestration
  - Helm:              Kubernetes package manager
  - Kustomize:         native K8s config customization tool
  - Vagrant


- Infrastructure & Configuration Management
  - Terraform:   IaC tool for provisioning infrastructure
  - Pulumi:      IaC using real languages like Python/TypeScript
  - Ansible:     Configuration management (agentless, YAML-based)
  - Chef:        Configuration management (Ruby DSL, client-server).
  - Puppet:      Declarative configuration management (Puppet DSL).

- Description:
  - Automated deployment of code to production environments.
  - Configuration Management tools like Ansible and Puppet ensure consistent environments across servers.
  - Containerization tools like Docker provide isolated environments for applications.

```
- Example:
  - Deploying a microservices app :
    - Package each service into Docker containers.
    - Use Kubernetes to auto-scale containers during traffic spikes.
```


**Stage 5: Continuous Monitoring**
-Tools used:
  
- Splunk:
  
    Log analysis & security monitoring

- ELK Stack:
  
    (Elasticsearch, Logstash, Kibana) – Open-source log management

- New Relic:
  
    Full-stack APM (app, infra, browser, mobile) is A cloud-based observability platform that provides real-time monitoring, tracing, and       performance analytics for applications and infrastructure.

- Prometheus:
  
    Prometheus is an open-source toolkit for collecting, monitoring, and alerting on time-series metrics, often used with Grafana for           visualization.

- Grafana:
  
    An open-source analytics and visualization platform used to create interactive dashboards from various data sources like Prometheus,        InfluxDB, and Elasticsearch.

- Datadog:
  
    All-in-one SaaS observability.
  
- Opentelemetry:
  
    Standard for collecting logs/metrics/traces.
  
- Dynatrace:
  
    AI-driven observability for enterprises.
  
- Nagios:
  
    Open-source monitoring for systems, networks, and infrastructure.

- Description:
  
  - Continuous monitoring involves tracking application performance and infrastructure health in real-time.
    
  - Monitoring tools collect and analyze logs, metrics, and other data to detect anomalies.
    
  - Ensures system reliability and facilitates proactive issue resolution.
    
  
```

- Example: Monitoring a cloud storage app:

- Prometheus: Alert if server CPU usage > 80%.

- ELK (Elasticsearch, Logstash, Kibana): Analyze logs to debug upload failures.

```
