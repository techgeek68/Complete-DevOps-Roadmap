# 12. Process Management, System Monitoring, and Performance Tuning

This section covers essential process management and system monitoring for DevOps engineers. It includes practical commands, tool usage, resource limits, troubleshooting, best practices for Linux systems, cloud/enterprise contexts, and advanced/enterprise integrations.

---

**12.1 Process Management**

**A. Process Monitoring Tools**

**ps - Process Status**
- Snapshot of current processes

**Key Columns:**  
- Key Columns in ps aux:
- USER: Process owner
- PID: Process ID (unique identifier)
- %CPU: CPU usage percentage
- %MEM: Memory usage percentage
- VSZ: Virtual memory size
- RSS: Resident Set Size (physical memory)
- TTY: Terminal associated
- STAT: Process state
- START: Start time
- TIME: CPU time consumed
- COMMAND: Command line

**Process States (STAT column):**

 - R: Running or runnable
 - S: Interruptible sleep
 - D: Uninterruptible sleep
 - Z: Zombie process
 - T: Stopped
 - <: High priority
 - N: Low priority
  
```
# BSD-style (most commonly used)
ps aux
```

```
# Unix-style
ps -ef
```

```
# Show process tree
ps auxf
```

```
# Show processes for the specific user
Syntax: ps -u username

# Example:
ps -u cnode
```
<img width="678" height="128" alt="Screenshot 2025-10-29 at 12 13 37 PM" src="https://github.com/user-attachments/assets/fe5f4bde-135e-4f3f-9269-225bae7ed852" />

```
# Show processes by name
ps -C sshd
ps aux | grep nginx
```
<img width="1194" height="314" alt="Screenshot 2025-10-29 at 12 15 38 PM" src="https://github.com/user-attachments/assets/2133784a-e723-45d5-b12f-51841e7b7d56" />


```
# Show specific columns
ps -eo pid,ppid,user,%cpu,%mem,command
```
<img width="824" height="205" alt="Screenshot 2025-10-29 at 12 16 58 PM" src="https://github.com/user-attachments/assets/968a7005-a042-4bd7-a351-a11906634030" />


**top - Real-time Process Monitor**
- Interactive Process Viewer:
  ```bash
  top
  ```

**Key Interactive Commands in top:**
   Key	    Action
  - k	      Kill process (prompts for PID)
  - M	      Sort by memory usage
  - P	      Sort by CPU usage
  - T	      Sort by time
  - u	      Show processes for the specific user
  - 1	      Show individual CPU cores
  - h	      Help
  - q	      Quit

<img width="698" height="210" alt="Screenshot 2025-10-29 at 12 33 05 PM" src="https://github.com/user-attachments/assets/7e67f3d5-bc41-4dbb-a823-4d06c743d848" />


**Header Information:**
  - Load average: 1min, 5min, 15min
  - Tasks: Total, running, sleeping, stopped, zombie
  - %Cpu(s): User, system, idle, wait time
  - Memory: Total, free, used, buffers/cache
  - Swap: Total, free, used

**Key Columns:**
  - PID: Process ID (unique identifier)
  - USER: Process owner
  - PR: Priority of the process
  - NI: Nice value (priority adjustment, -20 to 19)
  - VIRT: Virtual memory size
  - RES: Resident memory (physical RAM used)
  - SHR: Shared memory
  - S: Process state (`R`=Running, `S`=Sleeping, `D`=Uninterruptible sleep, `T`=Stopped, `Z`=Zombie)
  - %CPU: CPU usage percentage
  - %MEM: Memory usage percentage
  - TIME+: Total CPU time consumed
  - COMMAND: Command or program name
  
<img width="893" height="803" alt="Screenshot 2025-10-29 at 12 24 29 PM" src="https://github.com/user-attachments/assets/f7a3049a-b181-49ec-9126-b6b3e0542f11" />



**htop - Enhanced Process Viewer**
- Improved interactive process viewer with color and tree view.

**Install:**  
```bash
# RHEL/CentOS/Fedora
sudo dnf install epel-release -y
sudo dnf install htop -y

# Ubuntu/Debian
sudo apt update
sudo apt install htop -y
```

**Run:**  
  ```bash
  htop
  ```
  
<img width="1286" height="802" alt="Screenshot 2025-10-29 at 12 49 10 PM" src="https://github.com/user-attachments/assets/498b744b-42f3-43d2-b4bf-ab6328ef1d7e" />

**Interactive Features:**
    Key	    Action
  - F1	     Help
  - F2	     Setup/configure
  - F3	     Search process
  - F4	     Filter processes
  - F5	     Tree view (process hierarchy)
  - F6	     Sort by column
  - F7	     Decrease nice value (higher priority)
  - F8	     Increase nice value (lower priority)
  - F9	     Kill process (send signal)
  - F10	     Quit

  
**Advantages over top:**
  - Color-coded display
  - Vertical and horizontal scrolling
  - Mouse support
  - Better tree visualization
  - Easy process killing and priority adjustment


> Use `htop` for intuitive resource usage and process tree visualization.




**Additional Process Monitoring Tools**

 - pstree - Process Tree Display
```
# Show process tree
pstree

# Show PIDs
pstree -p

# Show for specific user
pstree -u username
```

 - pgrep & pkill - Process Grep/Kill
```
# Find process IDs by name
pgrep nginx
pgrep -u root

# Kill processes by name
pkill nginx
pkill -u username process_name
```

 - pidof - Find PID of Running Program
```
pidof sshd
pidof nginx
```


**Process Information Files**
 - /proc Filesystem
```
# Process details
cat /proc/<PID>/status

# Process environment
cat /proc/<PID>/environ

# Open files
ls -la /proc/<PID>/fd/
```

<img width="571" height="89" alt="Screenshot 2025-10-29 at 12 57 49 PM" src="https://github.com/user-attachments/assets/95c8a872-9f86-4705-917c-85d8c334211f" />


**B. Managing Background Jobs**

**Job Control Fundamentals**

- **Starting Background Jobs:**  

```bash
# Start command in background
sleep 60 &

# Output: [1] 1234  (Job ID: 1, Process ID: 1234)

# Start multiple background jobs
sleep 30 &
sleep 45 &
sleep 60 &
```
  Output: `[1] 12345` (job ID 1, PID 12345)

<img width="875" height="158" alt="Screenshot 2025-10-29 at 1 04 49 PM" src="https://github.com/user-attachments/assets/f8188bc4-7a8d-4062-a3c6-2120039dae2c" />

  
- **Job Management:**  
```bash
# List current jobs
jobs

# Output: 
# [1]   Running    sleep 60 &
# [2]   Stopped    vim file.txt
# [3]-  Running    find / -name "*.log" &
# [4]+  Stopped    top

# List with process IDs
jobs -l

# List with more details
jobs -p
```
![Uploading Screenshot 2025-10-29 at 1.07.08 PM.png…]()


**Job Control Operations**
```bash
# Bring background job to foreground
fg %1

# Suspend current foreground job
Ctrl + Z
# Job stops and returns to shell with message: [1]+  Stopped    sleep 60

# Resume suspended job in background
bg %1

# Bring most recent job to foreground
fg
```

<img width="687" height="165" alt="Screenshot 2025-10-29 at 1 11 49 PM" src="https://github.com/user-attachments/assets/b8588f54-5d32-4842-945d-9cafeaf0621b" />

<img width="799" height="185" alt="Screenshot 2025-10-29 at 1 14 08 PM" src="https://github.com/user-attachments/assets/d32d36f8-19bf-440d-8dd8-c176f466c54e" />


**Advanced Job Control**

**Referencing Jobs**
```bash
# By job number
%1                      #Job number 1
%2                      #Job number 2

# By process name
%sleep                  #Job running 'sleep'
%?vim                   #Job containing 'vim' in command

# Special references
%%                      #Current job (the one most recently activated)
%+                      #Current job
%-                      #Previous job
```

Job States:
  - Running: Job is executing in the background
  - Stopped: Job is suspended (with Ctrl+Z)
  - Done: Job has completed execution

**Terminating Jobs**
```bash
# Kill specific job
kill %1

# Kill by process name
kill %sleep

# Send the specific signal
kill -TERM %1
kill -KILL %2
```

<img width="816" height="373" alt="Screenshot 2025-10-29 at 1 21 13 PM" src="https://github.com/user-attachments/assets/4470ec1c-a25f-4885-b1bb-6241029f5837" />

**Examples**

**Example 1: Development Workflow**
```bash
# Start web server in the background
python -m http.server 8000 &
[1] 23456

# Start database in the background
mongod --dbpath /data/db &
[2] 23467

# List a jobs
jobs
# [1]   Running    python -m http.server 8000 &
# [2]   Running    mongod --dbpath /data/db &

# Bring a web server to the foreground to check logs
fg %1
# Press Ctrl+Z to suspend, then bg to return to background
```

**Example 2: File Operations**
```
# Start large file copy in background
cp -r large_directory /backup/ &
[1] 24567

# Check job status periodically
jobs -l
# [1]  24567 Running    cp -r large_directory /backup/ &

# Continue working while copy runs in background
```

**Example 3: Interactive Session Management**
```
# Start text editor
vim document.txt
# Press Ctrl+Z to suspend
# [1]+  Stopped    vim document.txt

# Do other work, then return to editor
fg %1
```

> Manage long-running or interactive tasks using job control. Always check with `jobs`.

---

**C. Process Signals**

- Signals are software interrupts for processes.
- **Common Signals:**
  | Signal Name | Number | Description                    |
  |-------------|--------|--------------------------------|
  | SIGHUP      | 1      | Hangup (reload config)         |
  | SIGINT      | 2      | Interrupt (Ctrl+C)             |
  | SIGKILL     | 9      | Force termination (cannot ignore)|
  | SIGTERM     | 15     | Graceful termination (default) |

**Send signals:**
- **Force-kill process:**  
  ```bash
  kill -9 12345
  ```
- **Graceful termination:**  
  ```bash
  kill -15 12345
  ```
- **Kill all by name:**  
  ```bash
  killall -9 process_name
  pkill firefox
  ```

**Process Types:**
- **Zombie:** Finished, entry remains; usually harmless.
- **Orphan:** Parent died, adopted by init (PID 1).

 
> Prefer `SIGTERM` (15) over `SIGKILL` (9) for cleanup. Use tree view (`htop`, `pstree`) to avoid killing critical processes.


---


## 13.1 System Monitoring and Performance Tuning

**A. Monitoring System Performance**

**`vmstat` (Virtual Memory Statistics)**
- Overview: virtual memory, processes, CPU, I/O.
- **Run:**  
  ```bash
  vmstat 1
  ```
  (Updates every 1 second)
- **Key metrics:**  
  - `r`: Running processes
  - `b`: Uninterruptible sleep
  - `free`: Free memory
  - `si/so`: Swap in/out
  - `wa`: I/O wait

**`iostat` (I/O Statistics)**
- **Install:**  
  ```bash
  sudo dnf install sysstat -y
  ```
- **Run:**  
  ```bash
  iostat
  ```
  (Displays CPU and device I/O usage)

**`sar` (System Activity Reporter)**
- **Install:**  
  ```bash
  sudo dnf install sysstat -y
  ```
- **Run:**  
  ```bash
  sar
  ```
  (Historical and real-time performance data)

**`free` (Memory Usage)**
- **Run:**  
  ```bash
  free -h
  ```
  (Human-readable RAM and swap usage)

**`htop` (Real-Time Monitoring)**
- Color-coded metrics: CPU, memory, swap.
- Sort: F6 (by CPU%, MEM%, user)
- Kill: F9
- Tree: F5


> Use `htop` for interactive and visual monitoring; combine with `vmstat`, `iostat`, `sar` for deep analysis.

---

**B. Setting Resource Limits**

**`ulimit`**
- Limit resources for the current shell/process.
- **Check limits:**  
  ```bash
  ulimit -a
  ```
- **Set file descriptor limit:**  
  ```bash
  ulimit -n 4096
  ```
- **Set max user processes:**  
  ```bash
  ulimit -u 2048
  ```

**Persistent Limits**
- Set in `/etc/security/limits.conf`:
  ```
  username soft nofile 4096
  username hard nofile 8192
  ```

**`cgroups` (Control Groups)**
- Kernel feature for resource isolation.
- **Create cgroup with limited memory:**
  ```bash
  sudo cgcreate -g memory:/mygroup
  sudo cgset -r memory.limit_in_bytes=256M mygroup
  sudo cgexec -g memory:/mygroup ./myprocess
  ```
- In containers/Kubernetes, resource limits (`resources.requests`/`resources.limits`) are set in pod specs.

**Advanced cgroups (v2) and systemd resource slices**
- **cgroup v2** offers the unified hierarchy and better resource control.
- **systemd slices**: Used to group and limit system services.
  - Example: Configure service limits in `/etc/systemd/system/myservice.service`
    ```
    [Service]
    CPUQuota=50%
    MemoryMax=256M
    ```
  - Place services into slices for isolation:
    ```
    [Unit]
    Slice=custom.slice
    ```

> Always set sensible resource limits for production processes to avoid system exhaustion. Use cgroup v2 and systemd slices for fine-grained control in modern systems.

---

## 13.2 Troubleshooting & Examples

| Symptom            | Diagnostic Command      | Likely Cause             | Resolution                   |
|--------------------|------------------------|--------------------------|------------------------------|
| High CPU usage     | `top`, `htop`          | Runaway process          | Kill, restart, tune process  |
| Memory exhaustion  | `free -h`, `htop`      | Memory leak, swap usage  | Kill, limit, add RAM         |
| IO bottleneck      | `iostat`, `vmstat`     | Disk saturation          | Optimize IO, SSD, tune app   |
| Process crashed    | `ps`, `journalctl`     | Segfault, OOM, SIGKILL   | Check logs, restart process  |
| Zombie processes   | `ps aux | grep Z`      | Defunct child processes  | Usually self-cleaning        |

---

## 13.3 Cloud/Container & Enterprise Monitoring Integrations

**A. Enterprise Monitoring**

- **Prometheus**:  
  - Time-series database, collects metrics via exporters.
  - Integrate with **Grafana** for dashboards and alerting.
  - Example:
    ```bash
    # Query Prometheus for CPU usage
    avg(rate(process_cpu_seconds_total[5m]))
    ```
  - Visualize and set alerts in Grafana.

- **New Relic / Datadog / Splunk**:  
  - Agents installed on hosts/containers.
  - Application and infrastructure metrics, traces, and logs.
  - Dashboards, alerting, anomaly detection.
  - Cloud platform integrations for deep visibility.

 
> Centralize monitoring using enterprise platforms. Use labels/tags for environments and automate dashboard/report generation.

---

**B. Automated Alerting and Remediation**

- Monitor resource usage and process health.
- **Automated Scripts/Ansible**:
  - Trigger remediation scripts on alert (restart services, scale resources).
- **PagerDuty Integration**:
  - Connect monitoring tools to PagerDuty for incident escalation.
- **Example workflow**:
  - Prometheus alert triggers webhook → Ansible playbook restarts service or scales deployment.
  - Datadog detects anomaly → sends alert to PagerDuty → Ops on-call notified.


> Automate remediation for known failure scenarios. Always run playbooks/scripts with logging and dry-run mode for safety.

---

**C. Application-Level Monitoring (APM)**

- **APM tools** (New Relic, Datadog, Splunk, Elastic APM):
  - Instrument applications for response time, error rate, and transaction traces.
  - Identify code-level bottlenecks and slow queries.
  - Integrate with CI/CD pipelines for release monitoring.


> Instrument all critical applications and services. Set up alerting for latency/error thresholds.

---

### D. **Advanced Container Orchestration Metrics**

- **Kubernetes Horizontal Pod Autoscaler (HPA)**:
  - Automatically scales pods based on CPU/memory/custom metrics.
  - Example spec:
    ```yaml
    apiVersion: autoscaling/v2
    kind: HorizontalPodAutoscaler
    metadata:
      name: web-hpa
    spec:
      scaleTargetRef:
        apiVersion: apps/v1
        kind: Deployment
        name: web
      minReplicas: 2
      maxReplicas: 10
      metrics:
      - type: Resource
        resource:
          name: cpu
          target:
            type: Utilization
            averageUtilization: 60
    ```
- **Node Autoscaling:**
  - Cloud providers support autoscaling clusters based on resource demand.
  - Integrate monitoring tools to trigger scale operations.


> Always define resource requests/limits for containers. Use HPA and node autoscaling for resilient, cost-effective infrastructure.

---

## 13.4 Security & Best Practices

| Area         | Recommendation                                                        |
|--------------|-----------------------------------------------------------------------|
| Process kill | Prefer SIGTERM, avoid SIGKILL unless necessary                        |
| Monitoring   | Combine multiple tools for full system insight                        |
| Limits       | Always set ulimit and cgroups/resource limits for critical services   |
| Visualization| Use color/tree view with htop for clarity                            |
| Automation   | Monitor resource usage and auto-restart unhealthy services            |
| Cloud        | Integrate with cloud-native and enterprise monitoring/alerting tools  |
| APM          | Instrument apps for code-level monitoring and error tracking          |
| Orchestration| Use HPA and node autoscaling for scalable workloads                   |

---


## 13.5 References (Suggested Further Study)

- `man ps`, `man top`, `man htop`, `man kill`, `man pkill`, `man killall`
- `man vmstat`, `man iostat`, `man sar`, `man free`
- `man ulimit`, `man cgroups`
- [Linux Process Management](https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html)
- [htop](https://htop.dev/)
- [Kubernetes Resource Management](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)
- [Kubernetes HPA](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)
- [Prometheus](https://prometheus.io/docs/introduction/overview/)
- [Grafana](https://grafana.com/docs/)
- [New Relic](https://docs.newrelic.com/docs/apm/)
- [Datadog Infrastructure Monitoring](https://docs.datadoghq.com/infrastructure/)
- [Splunk Observability](https://docs.splunk.com/Documentation/Observability)
- [Elastic APM](https://www.elastic.co/guide/en/apm/get-started/current/overview.html)
- [AWS CloudWatch](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html)
- [Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/)
- [GCP Monitoring](https://cloud.google.com/monitoring/docs)

---
